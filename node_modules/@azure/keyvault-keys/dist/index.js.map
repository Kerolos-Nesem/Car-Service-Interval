{"version":3,"file":"index.js","sources":["../src/log.ts","../src/generated/models/mappers.ts","../src/generated/models/parameters.ts","../src/generated/keyVaultClientContext.ts","../src/generated/keyVaultClient.ts","../src/constants.ts","../../keyvault-common/src/challengeBasedAuthenticationPolicy.ts","../../keyvault-common/src/parseKeyvaultIdentifier.ts","../../keyvault-common/src/tracingHelpers.ts","../src/identifier.ts","../src/transformations.ts","../src/lro/keyVaultKeyPoller.ts","../src/lro/delete/operation.ts","../src/lro/delete/poller.ts","../src/lro/recover/operation.ts","../src/lro/recover/poller.ts","../src/keysModels.ts","../src/cryptography/crypto.ts","../src/cryptography/remoteCryptographyProvider.ts","../src/cryptography/conversions.ts","../src/cryptography/models.ts","../src/cryptography/rsaCryptographyProvider.ts","../src/cryptography/aesCryptographyProvider.ts","../src/cryptographyClient.ts","../src/index.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The \\@azure/logger configuration for this package.\n */\nexport const logger = createClientLogger(\"keyvault-keys\");\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\n\nexport const KeyCreateParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyCreateParameters\",\n    modelProperties: {\n      kty: {\n        serializedName: \"kty\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      keySize: {\n        serializedName: \"key_size\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      publicExponent: {\n        serializedName: \"public_exponent\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      curve: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const Attributes: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"Attributes\",\n    modelProperties: {\n      enabled: {\n        serializedName: \"enabled\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      notBefore: {\n        serializedName: \"nbf\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      expires: {\n        serializedName: \"exp\",\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      created: {\n        serializedName: \"created\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      updated: {\n        serializedName: \"updated\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyBundle: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyBundle\",\n    modelProperties: {\n      key: {\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      managed: {\n        serializedName: \"managed\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const JsonWebKey: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"JsonWebKey\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      kty: {\n        serializedName: \"kty\",\n        type: {\n          name: \"String\"\n        }\n      },\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      n: {\n        serializedName: \"n\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      e: {\n        serializedName: \"e\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      d: {\n        serializedName: \"d\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      dp: {\n        serializedName: \"dp\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      dq: {\n        serializedName: \"dq\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      qi: {\n        serializedName: \"qi\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      p: {\n        serializedName: \"p\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      q: {\n        serializedName: \"q\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      k: {\n        serializedName: \"k\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      t: {\n        serializedName: \"key_hsm\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      crv: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      },\n      x: {\n        serializedName: \"x\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      y: {\n        serializedName: \"y\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVaultError: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVaultError\",\n    modelProperties: {\n      error: {\n        serializedName: \"error\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const ErrorModel: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"ErrorModel\",\n    modelProperties: {\n      code: {\n        serializedName: \"code\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      message: {\n        serializedName: \"message\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      innerError: {\n        serializedName: \"innererror\",\n        type: {\n          name: \"Composite\",\n          className: \"ErrorModel\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyImportParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyImportParameters\",\n    modelProperties: {\n      hsm: {\n        serializedName: \"Hsm\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      key: {\n        serializedName: \"key\",\n        type: {\n          name: \"Composite\",\n          className: \"JsonWebKey\"\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      }\n    }\n  }\n};\n\nexport const KeyUpdateParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyUpdateParameters\",\n    modelProperties: {\n      keyOps: {\n        serializedName: \"key_ops\",\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"String\"\n            }\n          }\n        }\n      },\n      keyAttributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      }\n    }\n  }\n};\n\nexport const KeyListResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyListResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"KeyItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyItem: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyItem\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        type: {\n          name: \"String\"\n        }\n      },\n      attributes: {\n        serializedName: \"attributes\",\n        type: {\n          name: \"Composite\",\n          className: \"KeyAttributes\"\n        }\n      },\n      tags: {\n        serializedName: \"tags\",\n        type: {\n          name: \"Dictionary\",\n          value: { type: { name: \"String\" } }\n        }\n      },\n      managed: {\n        serializedName: \"managed\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const BackupKeyResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"BackupKeyResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyRestoreParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyRestoreParameters\",\n    modelProperties: {\n      keyBundleBackup: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyOperationsParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyOperationsParameters\",\n    modelProperties: {\n      algorithm: {\n        serializedName: \"alg\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      value: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      iv: {\n        serializedName: \"iv\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      additionalAuthenticatedData: {\n        serializedName: \"aad\",\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      authenticationTag: {\n        serializedName: \"tag\",\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyOperationResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyOperationResult\",\n    modelProperties: {\n      kid: {\n        serializedName: \"kid\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      result: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      iv: {\n        serializedName: \"iv\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      authenticationTag: {\n        serializedName: \"tag\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      additionalAuthenticatedData: {\n        serializedName: \"aad\",\n        readOnly: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeySignParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeySignParameters\",\n    modelProperties: {\n      algorithm: {\n        serializedName: \"alg\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      value: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVerifyParameters: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVerifyParameters\",\n    modelProperties: {\n      algorithm: {\n        serializedName: \"alg\",\n        required: true,\n        type: {\n          name: \"String\"\n        }\n      },\n      digest: {\n        serializedName: \"digest\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      },\n      signature: {\n        serializedName: \"value\",\n        required: true,\n        type: {\n          name: \"Base64Url\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyVerifyResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyVerifyResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Boolean\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyListResult: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyListResult\",\n    modelProperties: {\n      value: {\n        serializedName: \"value\",\n        readOnly: true,\n        type: {\n          name: \"Sequence\",\n          element: {\n            type: {\n              name: \"Composite\",\n              className: \"DeletedKeyItem\"\n            }\n          }\n        }\n      },\n      nextLink: {\n        serializedName: \"nextLink\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyProperties: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyProperties\",\n    modelProperties: {\n      exportable: {\n        serializedName: \"exportable\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      keyType: {\n        serializedName: \"kty\",\n        type: {\n          name: \"String\"\n        }\n      },\n      keySize: {\n        serializedName: \"key_size\",\n        type: {\n          name: \"Number\"\n        }\n      },\n      reuseKey: {\n        serializedName: \"reuse_key\",\n        type: {\n          name: \"Boolean\"\n        }\n      },\n      curve: {\n        serializedName: \"crv\",\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const KeyAttributes: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"KeyAttributes\",\n    modelProperties: {\n      ...Attributes.type.modelProperties,\n      recoverableDays: {\n        serializedName: \"recoverableDays\",\n        readOnly: true,\n        type: {\n          name: \"Number\"\n        }\n      },\n      recoveryLevel: {\n        serializedName: \"recoveryLevel\",\n        readOnly: true,\n        type: {\n          name: \"String\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyBundle: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyBundle\",\n    modelProperties: {\n      ...KeyBundle.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        serializedName: \"scheduledPurgeDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        serializedName: \"deletedDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n\nexport const DeletedKeyItem: coreHttp.CompositeMapper = {\n  type: {\n    name: \"Composite\",\n    className: \"DeletedKeyItem\",\n    modelProperties: {\n      ...KeyItem.type.modelProperties,\n      recoveryId: {\n        serializedName: \"recoveryId\",\n        type: {\n          name: \"String\"\n        }\n      },\n      scheduledPurgeDate: {\n        serializedName: \"scheduledPurgeDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      },\n      deletedDate: {\n        serializedName: \"deletedDate\",\n        readOnly: true,\n        type: {\n          name: \"UnixTime\"\n        }\n      }\n    }\n  }\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport {\n  OperationParameter,\n  OperationURLParameter,\n  OperationQueryParameter\n} from \"@azure/core-http\";\nimport {\n  KeyCreateParameters as KeyCreateParametersMapper,\n  KeyImportParameters as KeyImportParametersMapper,\n  KeyUpdateParameters as KeyUpdateParametersMapper,\n  KeyRestoreParameters as KeyRestoreParametersMapper,\n  KeyOperationsParameters as KeyOperationsParametersMapper,\n  KeySignParameters as KeySignParametersMapper,\n  KeyVerifyParameters as KeyVerifyParametersMapper\n} from \"../models/mappers\";\n\nexport const contentType: OperationParameter = {\n  parameterPath: [\"options\", \"contentType\"],\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Content-Type\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const accept: OperationParameter = {\n  parameterPath: \"accept\",\n  mapper: {\n    defaultValue: \"application/json\",\n    isConstant: true,\n    serializedName: \"Accept\",\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const kty: OperationParameter = {\n  parameterPath: \"kty\",\n  mapper: KeyCreateParametersMapper\n};\n\nexport const keySize: OperationParameter = {\n  parameterPath: [\"options\", \"keySize\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const publicExponent: OperationParameter = {\n  parameterPath: [\"options\", \"publicExponent\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const keyOps: OperationParameter = {\n  parameterPath: [\"options\", \"keyOps\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const keyAttributes: OperationParameter = {\n  parameterPath: [\"options\", \"keyAttributes\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const tags: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const curve: OperationParameter = {\n  parameterPath: [\"options\", \"curve\"],\n  mapper: KeyCreateParametersMapper\n};\n\nexport const vaultBaseUrl: OperationURLParameter = {\n  parameterPath: \"vaultBaseUrl\",\n  mapper: {\n    serializedName: \"vaultBaseUrl\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n\nexport const keyName: OperationURLParameter = {\n  parameterPath: \"keyName\",\n  mapper: {\n    constraints: {\n      Pattern: new RegExp(\"^[0-9a-zA-Z-]+$\")\n    },\n    serializedName: \"key-name\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const apiVersion: OperationQueryParameter = {\n  parameterPath: \"apiVersion\",\n  mapper: {\n    serializedName: \"api-version\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const hsm: OperationParameter = {\n  parameterPath: [\"options\", \"hsm\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const key: OperationParameter = {\n  parameterPath: \"key\",\n  mapper: KeyImportParametersMapper\n};\n\nexport const keyAttributes1: OperationParameter = {\n  parameterPath: [\"options\", \"keyAttributes\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const tags1: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: KeyImportParametersMapper\n};\n\nexport const keyName1: OperationURLParameter = {\n  parameterPath: \"keyName\",\n  mapper: {\n    serializedName: \"key-name\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const keyOps1: OperationParameter = {\n  parameterPath: [\"options\", \"keyOps\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const keyAttributes2: OperationParameter = {\n  parameterPath: [\"options\", \"keyAttributes\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const tags2: OperationParameter = {\n  parameterPath: [\"options\", \"tags\"],\n  mapper: KeyUpdateParametersMapper\n};\n\nexport const keyVersion: OperationURLParameter = {\n  parameterPath: \"keyVersion\",\n  mapper: {\n    serializedName: \"key-version\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  }\n};\n\nexport const maxresults: OperationQueryParameter = {\n  parameterPath: [\"options\", \"maxresults\"],\n  mapper: {\n    constraints: {\n      InclusiveMaximum: 25,\n      InclusiveMinimum: 1\n    },\n    serializedName: \"maxresults\",\n    type: {\n      name: \"Number\"\n    }\n  }\n};\n\nexport const keyBundleBackup: OperationParameter = {\n  parameterPath: \"keyBundleBackup\",\n  mapper: KeyRestoreParametersMapper\n};\n\nexport const algorithm: OperationParameter = {\n  parameterPath: \"algorithm\",\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const value: OperationParameter = {\n  parameterPath: \"value\",\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const iv: OperationParameter = {\n  parameterPath: [\"options\", \"iv\"],\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const additionalAuthenticatedData: OperationParameter = {\n  parameterPath: [\"options\", \"additionalAuthenticatedData\"],\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const authenticationTag: OperationParameter = {\n  parameterPath: [\"options\", \"authenticationTag\"],\n  mapper: KeyOperationsParametersMapper\n};\n\nexport const algorithm1: OperationParameter = {\n  parameterPath: \"algorithm\",\n  mapper: KeySignParametersMapper\n};\n\nexport const value1: OperationParameter = {\n  parameterPath: \"value\",\n  mapper: KeySignParametersMapper\n};\n\nexport const algorithm2: OperationParameter = {\n  parameterPath: \"algorithm\",\n  mapper: KeyVerifyParametersMapper\n};\n\nexport const digest: OperationParameter = {\n  parameterPath: \"digest\",\n  mapper: KeyVerifyParametersMapper\n};\n\nexport const signature: OperationParameter = {\n  parameterPath: \"signature\",\n  mapper: KeyVerifyParametersMapper\n};\n\nexport const nextLink: OperationURLParameter = {\n  parameterPath: \"nextLink\",\n  mapper: {\n    serializedName: \"nextLink\",\n    required: true,\n    type: {\n      name: \"String\"\n    }\n  },\n  skipEncoding: true\n};\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport { ApiVersion72, KeyVaultClientOptionalParams } from \"./models\";\n\nconst packageName = \"@azure/keyvault-keys\";\nexport const packageVersion = \"4.3.0\";\n\n/** @hidden */\nexport class KeyVaultClientContext extends coreHttp.ServiceClient {\n  apiVersion: ApiVersion72;\n\n  /**\n   * Initializes a new instance of the KeyVaultClientContext class.\n   * @param apiVersion Api Version\n   * @param options The parameter options\n   */\n  constructor(\n    apiVersion: ApiVersion72,\n    options?: KeyVaultClientOptionalParams\n  ) {\n    if (apiVersion === undefined) {\n      throw new Error(\"'apiVersion' cannot be null\");\n    }\n\n    // Initializing default values for options\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.userAgent) {\n      const defaultUserAgent = coreHttp.getDefaultUserAgentValue();\n      options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;\n    }\n\n    super(undefined, options);\n\n    this.requestContentType = \"application/json; charset=utf-8\";\n\n    this.baseUri = options.endpoint || \"{vaultBaseUrl}\";\n\n    // Parameter assignments\n    this.apiVersion = apiVersion;\n  }\n}\n","/*\n * Copyright (c) Microsoft Corporation.\n * Licensed under the MIT License.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * Changes may cause incorrect behavior and will be lost if the code is regenerated.\n */\n\nimport * as coreHttp from \"@azure/core-http\";\nimport * as Parameters from \"./models/parameters\";\nimport * as Mappers from \"./models/mappers\";\nimport { KeyVaultClientContext } from \"./keyVaultClientContext\";\nimport {\n  KeyVaultClientOptionalParams,\n  ApiVersion72,\n  JsonWebKeyType,\n  KeyVaultClientCreateKeyOptionalParams,\n  KeyVaultClientCreateKeyResponse,\n  JsonWebKey,\n  KeyVaultClientImportKeyOptionalParams,\n  KeyVaultClientImportKeyResponse,\n  KeyVaultClientDeleteKeyResponse,\n  KeyVaultClientUpdateKeyOptionalParams,\n  KeyVaultClientUpdateKeyResponse,\n  KeyVaultClientGetKeyResponse,\n  KeyVaultClientGetKeyVersionsOptionalParams,\n  KeyVaultClientGetKeyVersionsResponse,\n  KeyVaultClientGetKeysOptionalParams,\n  KeyVaultClientGetKeysResponse,\n  KeyVaultClientBackupKeyResponse,\n  KeyVaultClientRestoreKeyResponse,\n  JsonWebKeyEncryptionAlgorithm,\n  KeyVaultClientEncryptOptionalParams,\n  KeyVaultClientEncryptResponse,\n  KeyVaultClientDecryptOptionalParams,\n  KeyVaultClientDecryptResponse,\n  JsonWebKeySignatureAlgorithm,\n  KeyVaultClientSignResponse,\n  KeyVaultClientVerifyResponse,\n  KeyVaultClientWrapKeyOptionalParams,\n  KeyVaultClientWrapKeyResponse,\n  KeyVaultClientUnwrapKeyOptionalParams,\n  KeyVaultClientUnwrapKeyResponse,\n  KeyVaultClientGetDeletedKeysOptionalParams,\n  KeyVaultClientGetDeletedKeysResponse,\n  KeyVaultClientGetDeletedKeyResponse,\n  KeyVaultClientRecoverDeletedKeyResponse,\n  KeyVaultClientGetKeyVersionsNextOptionalParams,\n  KeyVaultClientGetKeyVersionsNextResponse,\n  KeyVaultClientGetKeysNextOptionalParams,\n  KeyVaultClientGetKeysNextResponse,\n  KeyVaultClientGetDeletedKeysNextOptionalParams,\n  KeyVaultClientGetDeletedKeysNextResponse\n} from \"./models\";\n\n/** @hidden */\nexport class KeyVaultClient extends KeyVaultClientContext {\n  /**\n   * Initializes a new instance of the KeyVaultClient class.\n   * @param apiVersion Api Version\n   * @param options The parameter options\n   */\n  constructor(\n    apiVersion: ApiVersion72,\n    options?: KeyVaultClientOptionalParams\n  ) {\n    super(apiVersion, options);\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name for the new key. The system will generate the version name for the new key.\n   * @param kty The type of key to create. For valid values, see JsonWebKeyType.\n   * @param options The options parameters.\n   */\n  createKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    kty: JsonWebKeyType,\n    options?: KeyVaultClientCreateKeyOptionalParams\n  ): Promise<KeyVaultClientCreateKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      kty,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      createKeyOperationSpec\n    ) as Promise<KeyVaultClientCreateKeyResponse>;\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the named\n   * key already exists, Azure Key Vault creates a new version of the key. This operation requires the\n   * keys/import permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName Name for the imported key.\n   * @param key The Json web key\n   * @param options The options parameters.\n   */\n  importKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    key: JsonWebKey,\n    options?: KeyVaultClientImportKeyOptionalParams\n  ): Promise<KeyVaultClientImportKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      key,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      importKeyOperationSpec\n    ) as Promise<KeyVaultClientImportKeyResponse>;\n  }\n\n  /**\n   * The delete key operation cannot be used to remove individual versions of a key. This operation\n   * removes the cryptographic material associated with the key, which means the key is not usable for\n   * Sign/Verify, Wrap/Unwrap or Encrypt/Decrypt operations. This operation requires the keys/delete\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to delete.\n   * @param options The options parameters.\n   */\n  deleteKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientDeleteKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      deleteKeyOperationSpec\n    ) as Promise<KeyVaultClientDeleteKeyResponse>;\n  }\n\n  /**\n   * In order to perform this operation, the key must already exist in the Key Vault. Note: The\n   * cryptographic material of a key itself cannot be changed. This operation requires the keys/update\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of key to update.\n   * @param keyVersion The version of the key to update.\n   * @param options The options parameters.\n   */\n  updateKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    options?: KeyVaultClientUpdateKeyOptionalParams\n  ): Promise<KeyVaultClientUpdateKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      updateKeyOperationSpec\n    ) as Promise<KeyVaultClientUpdateKeyResponse>;\n  }\n\n  /**\n   * The get key operation is applicable to all key types. If the requested key is symmetric, then no key\n   * material is released in the response. This operation requires the keys/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key to get.\n   * @param keyVersion Adding the version parameter retrieves a specific version of a key. This URI\n   *                   fragment is optional. If not specified, the latest version of the key is returned.\n   * @param options The options parameters.\n   */\n  getKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientGetKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getKeyOperationSpec\n    ) as Promise<KeyVaultClientGetKeyResponse>;\n  }\n\n  /**\n   * The full key identifier, attributes, and tags are provided in the response. This operation requires\n   * the keys/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The options parameters.\n   */\n  getKeyVersions(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: KeyVaultClientGetKeyVersionsOptionalParams\n  ): Promise<KeyVaultClientGetKeyVersionsResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getKeyVersionsOperationSpec\n    ) as Promise<KeyVaultClientGetKeyVersionsResponse>;\n  }\n\n  /**\n   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public\n   * part of a stored key. The LIST operation is applicable to all key types, however only the base key\n   * identifier, attributes, and tags are provided in the response. Individual versions of a key are not\n   * listed in the response. This operation requires the keys/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The options parameters.\n   */\n  getKeys(\n    vaultBaseUrl: string,\n    options?: KeyVaultClientGetKeysOptionalParams\n  ): Promise<KeyVaultClientGetKeysResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getKeysOperationSpec\n    ) as Promise<KeyVaultClientGetKeysResponse>;\n  }\n\n  /**\n   * The Key Backup operation exports a key from Azure Key Vault in a protected form. Note that this\n   * operation does NOT return key material in a form that can be used outside the Azure Key Vault\n   * system, the returned key material is either protected to a Azure Key Vault HSM or to Azure Key Vault\n   * itself. The intent of this operation is to allow a client to GENERATE a key in one Azure Key Vault\n   * instance, BACKUP the key, and then RESTORE it into another Azure Key Vault instance. The BACKUP\n   * operation may be used to export, in protected form, any key type from Azure Key Vault. Individual\n   * versions of a key cannot be backed up. BACKUP / RESTORE can be performed within geographical\n   * boundaries only; meaning that a BACKUP from one geographical area cannot be restored to another\n   * geographical area. For example, a backup from the US geographical area cannot be restored in an EU\n   * geographical area. This operation requires the key/backup permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The options parameters.\n   */\n  backupKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientBackupKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      backupKeyOperationSpec\n    ) as Promise<KeyVaultClientBackupKeyResponse>;\n  }\n\n  /**\n   * Imports a previously backed up key into Azure Key Vault, restoring the key, its key identifier,\n   * attributes and access control policies. The RESTORE operation may be used to import a previously\n   * backed up key. Individual versions of a key cannot be restored. The key is restored in its entirety\n   * with the same key name as it had when it was backed up. If the key name is not available in the\n   * target Key Vault, the RESTORE operation will be rejected. While the key name is retained during\n   * restore, the final key identifier will change if the key is restored to a different vault. Restore\n   * will restore all versions and preserve version identifiers. The RESTORE operation is subject to\n   * security constraints: The target Key Vault must be owned by the same Microsoft Azure Subscription as\n   * the source Key Vault The user must have RESTORE permission in the target Key Vault. This operation\n   * requires the keys/restore permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyBundleBackup The backup blob associated with a key bundle.\n   * @param options The options parameters.\n   */\n  restoreKey(\n    vaultBaseUrl: string,\n    keyBundleBackup: Uint8Array,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientRestoreKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyBundleBackup,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      restoreKeyOperationSpec\n    ) as Promise<KeyVaultClientRestoreKeyResponse>;\n  }\n\n  /**\n   * The ENCRYPT operation encrypts an arbitrary sequence of bytes using an encryption key that is stored\n   * in Azure Key Vault. Note that the ENCRYPT operation only supports a single block of data, the size\n   * of which is dependent on the target key and the encryption algorithm to be used. The ENCRYPT\n   * operation is only strictly necessary for symmetric keys stored in Azure Key Vault since protection\n   * with an asymmetric key can be performed using public portion of the key. This operation is supported\n   * for asymmetric keys as a convenience for callers that have a key-reference but do not have access to\n   * the public key material. This operation requires the keys/encrypt permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  encrypt(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: KeyVaultClientEncryptOptionalParams\n  ): Promise<KeyVaultClientEncryptResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      algorithm,\n      value,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      encryptOperationSpec\n    ) as Promise<KeyVaultClientEncryptResponse>;\n  }\n\n  /**\n   * The DECRYPT operation decrypts a well-formed block of ciphertext using the target encryption key and\n   * specified algorithm. This operation is the reverse of the ENCRYPT operation; only a single block of\n   * data may be decrypted, the size of this block is dependent on the target key and the algorithm to be\n   * used. The DECRYPT operation applies to asymmetric and symmetric keys stored in Azure Key Vault since\n   * it uses the private portion of the key. This operation requires the keys/decrypt permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  decrypt(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: KeyVaultClientDecryptOptionalParams\n  ): Promise<KeyVaultClientDecryptResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      algorithm,\n      value,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      decryptOperationSpec\n    ) as Promise<KeyVaultClientDecryptResponse>;\n  }\n\n  /**\n   * The SIGN operation is applicable to asymmetric and symmetric keys stored in Azure Key Vault since\n   * this operation uses the private portion of the key. This operation requires the keys/sign\n   * permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm identifier. For more information on possible\n   *                  algorithm types, see JsonWebKeySignatureAlgorithm.\n   * @param value\n   * @param options The options parameters.\n   */\n  sign(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeySignatureAlgorithm,\n    value: Uint8Array,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientSignResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      algorithm,\n      value,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      signOperationSpec\n    ) as Promise<KeyVaultClientSignResponse>;\n  }\n\n  /**\n   * The VERIFY operation is applicable to symmetric keys stored in Azure Key Vault. VERIFY is not\n   * strictly necessary for asymmetric keys stored in Azure Key Vault since signature verification can be\n   * performed using the public portion of the key but this operation is supported as a convenience for\n   * callers that only have a key-reference and not the public portion of the key. This operation\n   * requires the keys/verify permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm The signing/verification algorithm. For more information on possible algorithm\n   *                  types, see JsonWebKeySignatureAlgorithm.\n   * @param digest The digest used for signing.\n   * @param signature The signature to be verified.\n   * @param options The options parameters.\n   */\n  verify(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeySignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientVerifyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      algorithm,\n      digest,\n      signature,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      verifyOperationSpec\n    ) as Promise<KeyVaultClientVerifyResponse>;\n  }\n\n  /**\n   * The WRAP operation supports encryption of a symmetric key using a key encryption key that has\n   * previously been stored in an Azure Key Vault. The WRAP operation is only strictly necessary for\n   * symmetric keys stored in Azure Key Vault since protection with an asymmetric key can be performed\n   * using the public portion of the key. This operation is supported for asymmetric keys as a\n   * convenience for callers that have a key-reference but do not have access to the public key material.\n   * This operation requires the keys/wrapKey permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  wrapKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: KeyVaultClientWrapKeyOptionalParams\n  ): Promise<KeyVaultClientWrapKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      algorithm,\n      value,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      wrapKeyOperationSpec\n    ) as Promise<KeyVaultClientWrapKeyResponse>;\n  }\n\n  /**\n   * The UNWRAP operation supports decryption of a symmetric key using the target key encryption key.\n   * This operation is the reverse of the WRAP operation. The UNWRAP operation applies to asymmetric and\n   * symmetric keys stored in Azure Key Vault since it uses the private portion of the key. This\n   * operation requires the keys/unwrapKey permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param keyVersion The version of the key.\n   * @param algorithm algorithm identifier\n   * @param value\n   * @param options The options parameters.\n   */\n  unwrapKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    keyVersion: string,\n    algorithm: JsonWebKeyEncryptionAlgorithm,\n    value: Uint8Array,\n    options?: KeyVaultClientUnwrapKeyOptionalParams\n  ): Promise<KeyVaultClientUnwrapKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      keyVersion,\n      algorithm,\n      value,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      unwrapKeyOperationSpec\n    ) as Promise<KeyVaultClientUnwrapKeyResponse>;\n  }\n\n  /**\n   * Retrieves a list of the keys in the Key Vault as JSON Web Key structures that contain the public\n   * part of a deleted key. This operation includes deletion-specific information. The Get Deleted Keys\n   * operation is applicable for vaults enabled for soft-delete. While the operation can be invoked on\n   * any vault, it will return an error if invoked on a non soft-delete enabled vault. This operation\n   * requires the keys/list permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param options The options parameters.\n   */\n  getDeletedKeys(\n    vaultBaseUrl: string,\n    options?: KeyVaultClientGetDeletedKeysOptionalParams\n  ): Promise<KeyVaultClientGetDeletedKeysResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getDeletedKeysOperationSpec\n    ) as Promise<KeyVaultClientGetDeletedKeysResponse>;\n  }\n\n  /**\n   * The Get Deleted Key operation is applicable for soft-delete enabled vaults. While the operation can\n   * be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault. This\n   * operation requires the keys/get permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param options The options parameters.\n   */\n  getDeletedKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientGetDeletedKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getDeletedKeyOperationSpec\n    ) as Promise<KeyVaultClientGetDeletedKeyResponse>;\n  }\n\n  /**\n   * The Purge Deleted Key operation is applicable for soft-delete enabled vaults. While the operation\n   * can be invoked on any vault, it will return an error if invoked on a non soft-delete enabled vault.\n   * This operation requires the keys/purge permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key\n   * @param options The options parameters.\n   */\n  purgeDeletedKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<coreHttp.RestResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      purgeDeletedKeyOperationSpec\n    ) as Promise<coreHttp.RestResponse>;\n  }\n\n  /**\n   * The Recover Deleted Key operation is applicable for deleted keys in soft-delete enabled vaults. It\n   * recovers the deleted key back to its latest version under /keys. An attempt to recover an\n   * non-deleted key will return an error. Consider this the inverse of the delete operation on\n   * soft-delete enabled vaults. This operation requires the keys/recover permission.\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the deleted key.\n   * @param options The options parameters.\n   */\n  recoverDeletedKey(\n    vaultBaseUrl: string,\n    keyName: string,\n    options?: coreHttp.OperationOptions\n  ): Promise<KeyVaultClientRecoverDeletedKeyResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      recoverDeletedKeyOperationSpec\n    ) as Promise<KeyVaultClientRecoverDeletedKeyResponse>;\n  }\n\n  /**\n   * GetKeyVersionsNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param keyName The name of the key.\n   * @param nextLink The nextLink from the previous successful call to the GetKeyVersions method.\n   * @param options The options parameters.\n   */\n  getKeyVersionsNext(\n    vaultBaseUrl: string,\n    keyName: string,\n    nextLink: string,\n    options?: KeyVaultClientGetKeyVersionsNextOptionalParams\n  ): Promise<KeyVaultClientGetKeyVersionsNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      keyName,\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getKeyVersionsNextOperationSpec\n    ) as Promise<KeyVaultClientGetKeyVersionsNextResponse>;\n  }\n\n  /**\n   * GetKeysNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param nextLink The nextLink from the previous successful call to the GetKeys method.\n   * @param options The options parameters.\n   */\n  getKeysNext(\n    vaultBaseUrl: string,\n    nextLink: string,\n    options?: KeyVaultClientGetKeysNextOptionalParams\n  ): Promise<KeyVaultClientGetKeysNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getKeysNextOperationSpec\n    ) as Promise<KeyVaultClientGetKeysNextResponse>;\n  }\n\n  /**\n   * GetDeletedKeysNext\n   * @param vaultBaseUrl The vault name, for example https://myvault.vault.azure.net.\n   * @param nextLink The nextLink from the previous successful call to the GetDeletedKeys method.\n   * @param options The options parameters.\n   */\n  getDeletedKeysNext(\n    vaultBaseUrl: string,\n    nextLink: string,\n    options?: KeyVaultClientGetDeletedKeysNextOptionalParams\n  ): Promise<KeyVaultClientGetDeletedKeysNextResponse> {\n    const operationArguments: coreHttp.OperationArguments = {\n      vaultBaseUrl,\n      nextLink,\n      options: coreHttp.operationOptionsToRequestOptionsBase(options || {})\n    };\n    return this.sendOperationRequest(\n      operationArguments,\n      getDeletedKeysNextOperationSpec\n    ) as Promise<KeyVaultClientGetDeletedKeysNextResponse>;\n  }\n}\n// Operation Specifications\nconst serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);\n\nconst createKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/create\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      kty: [\"kty\"],\n      keySize: [\"options\", \"keySize\"],\n      publicExponent: [\"options\", \"publicExponent\"],\n      keyOps: [\"options\", \"keyOps\"],\n      keyAttributes: [\"options\", \"keyAttributes\"],\n      tags: [\"options\", \"tags\"],\n      curve: [\"options\", \"curve\"]\n    },\n    mapper: Mappers.KeyCreateParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst importKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}\",\n  httpMethod: \"PUT\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      hsm: [\"options\", \"hsm\"],\n      key: [\"key\"],\n      keyAttributes: [\"options\", \"keyAttributes\"],\n      tags: [\"options\", \"tags\"]\n    },\n    mapper: Mappers.KeyImportParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst deleteKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst updateKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}\",\n  httpMethod: \"PATCH\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      keyOps: [\"options\", \"keyOps\"],\n      keyAttributes: [\"options\", \"keyAttributes\"],\n      tags: [\"options\", \"tags\"]\n    },\n    mapper: Mappers.KeyUpdateParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeyVersionsOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/versions\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeysOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst backupKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/backup\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.BackupKeyResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst restoreKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/restore\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: { keyBundleBackup: [\"keyBundleBackup\"] },\n    mapper: Mappers.KeyRestoreParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst encryptOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/encrypt\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: Mappers.KeyOperationsParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst decryptOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/decrypt\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: Mappers.KeyOperationsParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst signOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/sign\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: { algorithm: [\"algorithm\"], value: [\"value\"] },\n    mapper: Mappers.KeySignParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst verifyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/verify\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyVerifyResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      digest: [\"digest\"],\n      signature: [\"signature\"]\n    },\n    mapper: Mappers.KeyVerifyParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst wrapKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/wrapkey\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: Mappers.KeyOperationsParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst unwrapKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/keys/{key-name}/{key-version}/unwrapkey\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyOperationResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  requestBody: {\n    parameterPath: {\n      algorithm: [\"algorithm\"],\n      value: [\"value\"],\n      iv: [\"options\", \"iv\"],\n      additionalAuthenticatedData: [\"options\", \"additionalAuthenticatedData\"],\n      authenticationTag: [\"options\", \"authenticationTag\"]\n    },\n    mapper: Mappers.KeyOperationsParameters\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.keyVersion\n  ],\n  headerParameters: [Parameters.contentType, Parameters.accept],\n  mediaType: \"json\",\n  serializer\n};\nconst getDeletedKeysOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedkeys\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedkeys/{key-name}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst purgeDeletedKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedkeys/{key-name}\",\n  httpMethod: \"DELETE\",\n  responses: {\n    204: {},\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst recoverDeletedKeyOperationSpec: coreHttp.OperationSpec = {\n  path: \"/deletedkeys/{key-name}/recover\",\n  httpMethod: \"POST\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyBundle\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.keyName1],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeyVersionsNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [\n    Parameters.vaultBaseUrl,\n    Parameters.keyName1,\n    Parameters.nextLink\n  ],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getKeysNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.KeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\nconst getDeletedKeysNextOperationSpec: coreHttp.OperationSpec = {\n  path: \"{nextLink}\",\n  httpMethod: \"GET\",\n  responses: {\n    200: {\n      bodyMapper: Mappers.DeletedKeyListResult\n    },\n    default: {\n      bodyMapper: Mappers.KeyVaultError\n    }\n  },\n  queryParameters: [Parameters.apiVersion, Parameters.maxresults],\n  urlParameters: [Parameters.vaultBaseUrl, Parameters.nextLink],\n  headerParameters: [Parameters.accept],\n  serializer\n};\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"4.3.0\";\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable @azure/azure-sdk/ts-use-interface-parameters */\n\nimport { TokenCredential } from \"@azure/core-http\";\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyOptions,\n  RequestPolicyFactory\n} from \"@azure/core-http\";\nimport { Constants } from \"@azure/core-http\";\nimport { HttpOperationResponse } from \"@azure/core-http\";\nimport { WebResource } from \"@azure/core-http\";\nimport { AccessTokenCache, ExpiringAccessTokenCache } from \"@azure/core-http\";\n\ntype ValidParsedWWWAuthenticateProperties =\n  // \"authorization_uri\" was used in the track 1 version of KeyVault.\n  // This is not a relevant property anymore, since the service is consistently answering with \"authorization\".\n  // | \"authorization_uri\"\n  | \"authorization\"\n  // Even though the service is moving to \"scope\", both \"resource\" and \"scope\" should be supported.\n  | \"resource\"\n  | \"scope\";\n\ntype ParsedWWWAuthenticate = {\n  [Key in ValidParsedWWWAuthenticateProperties]?: string;\n};\n\n/**\n * Representation of the Authentication Challenge\n */\nexport class AuthenticationChallenge {\n  constructor(public authorization: string, public scope: string) {}\n\n  /**\n   * Checks that this AuthenticationChallenge is equal to another one given.\n   * Only compares the scope.\n   * This is exactly what C# is doing, as we can see here:\n   * https://github.com/Azure/azure-sdk-for-net/blob/70e54b878ff1d01a45266fb3674a396b4ab9c1d2/sdk/keyvault/Azure.Security.KeyVault.Shared/src/ChallengeBasedAuthenticationPolicy.cs#L143-L147\n   * @param other - The other AuthenticationChallenge\n   */\n  public equalTo(other: AuthenticationChallenge | undefined): boolean {\n    return other\n      ? this.scope.toLowerCase() === other.scope.toLowerCase() &&\n          this.authorization.toLowerCase() === other.authorization.toLowerCase()\n      : false;\n  }\n}\n\n/**\n * Helps keep a copy of any previous authentication challenges,\n * so that we can compare on any further request.\n */\nexport class AuthenticationChallengeCache {\n  public challenge?: AuthenticationChallenge;\n\n  public setCachedChallenge(challenge: AuthenticationChallenge): void {\n    this.challenge = challenge;\n  }\n}\n\n/**\n * Creates a new ChallengeBasedAuthenticationPolicy factory.\n *\n * @param credential - The TokenCredential implementation that can supply the challenge token.\n */\nexport function challengeBasedAuthenticationPolicy(\n  credential: TokenCredential\n): RequestPolicyFactory {\n  const tokenCache: AccessTokenCache = new ExpiringAccessTokenCache();\n  const challengeCache = new AuthenticationChallengeCache();\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ChallengeBasedAuthenticationPolicy(\n        nextPolicy,\n        options,\n        credential,\n        tokenCache,\n        challengeCache\n      );\n    }\n  };\n}\n\n/**\n * Parses an WWW-Authenticate response.\n * This transforms a string value like:\n * `Bearer authorization=\"some_authorization\", resource=\"https://some.url\"`\n * into an object like:\n * `{ authorization: \"some_authorization\", resource: \"https://some.url\" }`\n * @param wwwAuthenticate - String value in the WWW-Authenticate header\n */\nexport function parseWWWAuthenticate(wwwAuthenticate: string): ParsedWWWAuthenticate {\n  // First we split the string by either `, ` or ` `.\n  const parts = wwwAuthenticate.split(/,* +/);\n  // Then we only keep the strings with an equal sign after a word and before a quote.\n  // also splitting these sections by their equal sign\n  const keyValues = parts.reduce<string[][]>(\n    (acc, str) => (str.match(/\\w=\"/) ? [...acc, str.split(\"=\")] : acc),\n    []\n  );\n  // Then we transform these key-value pairs back into an object.\n  const parsed = keyValues.reduce<ParsedWWWAuthenticate>(\n    (result, [key, value]: string[]) => ({\n      ...result,\n      [key]: value.slice(1, -1)\n    }),\n    {}\n  );\n  return parsed;\n}\n\n/**\n *\n * Provides a RequestPolicy that can request a token from a TokenCredential\n * implementation and then apply it to the Authorization header of a request\n * as a Bearer token.\n *\n */\nexport class ChallengeBasedAuthenticationPolicy extends BaseRequestPolicy {\n  private parseWWWAuthenticate: (\n    wwwAuthenticate: string\n  ) => ParsedWWWAuthenticate = parseWWWAuthenticate;\n\n  /**\n   * Creates a new ChallengeBasedAuthenticationPolicy object.\n   *\n   * @param nextPolicy - The next RequestPolicy in the request pipeline.\n   * @param options - Options for this RequestPolicy.\n   * @param credential - The TokenCredential implementation that can supply the bearer token.\n   * @param tokenCache - The cache for the most recent AccessToken returned by the TokenCredential.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private credential: TokenCredential,\n    private tokenCache: AccessTokenCache,\n    private challengeCache: AuthenticationChallengeCache\n  ) {\n    super(nextPolicy, options);\n  }\n\n  /**\n   * Gets or updates the token from the token cache into the headers of the received web resource.\n   */\n  private async loadToken(webResource: WebResource): Promise<void> {\n    let accessToken = this.tokenCache.getCachedToken();\n\n    // If there's no cached token in the cache, we try to get a new one.\n    if (accessToken === undefined) {\n      const receivedToken = await this.credential.getToken(this.challengeCache.challenge!.scope);\n      accessToken = receivedToken || undefined;\n      this.tokenCache.setCachedToken(accessToken);\n    }\n\n    if (accessToken) {\n      webResource.headers.set(\n        Constants.HeaderConstants.AUTHORIZATION,\n        `Bearer ${accessToken.token}`\n      );\n    }\n  }\n\n  /**\n   * Parses the given WWW-Authenticate header, generates a new AuthenticationChallenge,\n   * then if the challenge is different from the one cached, resets the token and forces\n   * a re-authentication, otherwise continues with the existing challenge and token.\n   * @param wwwAuthenticate - Value of the incoming WWW-Authenticate header.\n   * @param webResource - Ongoing HTTP request.\n   */\n  private async regenerateChallenge(\n    wwwAuthenticate: string,\n    webResource: WebResource\n  ): Promise<HttpOperationResponse> {\n    // The challenge based authentication will contain both:\n    // - An authorization URI with a token,\n    // - The resource to which that token is valid against (also called the scope).\n    const parsedWWWAuth = this.parseWWWAuthenticate(wwwAuthenticate);\n    const authorization = parsedWWWAuth.authorization!;\n    const resource = parsedWWWAuth.resource! || parsedWWWAuth.scope!;\n\n    if (!(authorization && resource)) {\n      return this._nextPolicy.sendRequest(webResource);\n    }\n\n    const challenge = new AuthenticationChallenge(authorization, resource + \"/.default\");\n\n    // Either if there's no cached challenge at this point (could have happen in parallel),\n    // or if the cached challenge has a different scope,\n    // we store the just received challenge and reset the cached token, to force a re-authentication.\n    if (!this.challengeCache.challenge?.equalTo(challenge)) {\n      this.challengeCache.setCachedChallenge(challenge);\n      this.tokenCache.setCachedToken(undefined);\n    }\n\n    await this.loadToken(webResource);\n    return this._nextPolicy.sendRequest(webResource);\n  }\n\n  /**\n   * Applies the Bearer token to the request through the Authorization header.\n   * @param webResource - Ongoing HTTP request.\n   */\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    // Ensure that we're about to use a secure connection.\n    if (!webResource.url.startsWith(\"https:\")) {\n      throw new Error(\"The resource address for authorization must use the 'https' protocol.\");\n    }\n\n    // The next request will happen differently whether we have a challenge or not.\n    let response: HttpOperationResponse;\n\n    if (\n      this.challengeCache.challenge === undefined ||\n      this.challengeCache.challenge === undefined\n    ) {\n      // If there's no challenge in cache, a blank body will start the challenge.\n      const originalBody = webResource.body;\n      webResource.body = \"\";\n      try {\n        response = await this._nextPolicy.sendRequest(webResource);\n      } finally {\n        webResource.body = originalBody;\n      }\n    } else {\n      // If we did have a challenge in memory,\n      // we attempt to load the token from the cache into the request before we try to send the request.\n      await this.loadToken(webResource);\n      response = await this._nextPolicy.sendRequest(webResource);\n    }\n\n    // If we don't receive a response with a 401 status code,\n    // then we can assume this response has nothing to do with the challenge authentication process.\n    if (response.status !== 401) {\n      return response;\n    }\n\n    // If the response status is 401, we only re-authenticate if the WWW-Authenticate header is present.\n    const wwwAuthenticate = response.headers.get(\"WWW-Authenticate\");\n    if (!wwwAuthenticate) {\n      return response;\n    }\n\n    // We re-generate the challenge and see if we have to re-authenticate.\n    return this.regenerateChallenge(wwwAuthenticate, webResource);\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as url from \"url\";\n\nexport interface ParsedKeyVaultEntityIdentifier {\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of key/secret/certificate. May be undefined.\n   */\n  version?: string;\n  /**\n   * The name of key/secret/certificate.\n   */\n  name: string;\n}\nexport function parseKeyvaultIdentifier(\n  collection: string,\n  identifier: string | undefined\n): ParsedKeyVaultEntityIdentifier {\n  if (typeof collection !== \"string\" || !(collection = collection.trim())) {\n    throw new Error(\"Invalid collection argument\");\n  }\n\n  if (typeof identifier !== \"string\" || !(identifier = identifier.trim())) {\n    throw new Error(\"Invalid identifier argument\");\n  }\n\n  let baseUri;\n  try {\n    baseUri = url.parse(identifier, true, true);\n  } catch (e) {\n    throw new Error(`Invalid ${collection} identifier: ${identifier}. Not a valid URI`);\n  }\n\n  // Path is of the form '/collection/name[/version]'\n  const segments = (baseUri.pathname || \"\").split(\"/\");\n  if (segments.length !== 3 && segments.length !== 4) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. Bad number of segments: ${segments.length}`\n    );\n  }\n\n  if (collection !== segments[1]) {\n    throw new Error(\n      `Invalid ${collection} identifier: ${identifier}. segment [1] should be \"${collection}\", found \"${segments[1]}\"`\n    );\n  }\n\n  const vaultUrl = `${baseUri.protocol}//${baseUri.host}`;\n  const name = segments[2];\n  const version = segments.length === 4 ? segments[3] : undefined;\n  return {\n    vaultUrl,\n    name,\n    version\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-http\";\nimport { createSpanFunction, Span, SpanStatusCode } from \"@azure/core-tracing\";\n\n/**\n * An interface representing a function that is traced.\n *\n * A traced function will automatically create and close tracing '\n * spans as needed and will handle setting the status / errors as a\n * result of calling the underlying callback.\n *\n * use {@link createTraceFunction} to add tracing to a block of code.\n *\n * @internal\n */\nexport interface TracedFunction {\n  <TOptions extends OperationOptions, TReturn>(\n    operationName: string,\n    options: TOptions,\n    cb: (options: TOptions, span: Span) => Promise<TReturn>\n  ): Promise<TReturn>;\n}\n\n/**\n * Returns a function that can be used for tracing options.\n *\n * @param prefix - The prefix to use, likely the name of the class / client.\n *\n * @example const withTrace = createTraceFunction(\"Azure.KeyVault.Certificates.CertificateClient\")\n *\n * @internal\n */\nexport function createTraceFunction(prefix: string): TracedFunction {\n  const createSpan = createSpanFunction({\n    namespace: \"Microsoft.KeyVault\",\n    packagePrefix: prefix\n  });\n\n  return async function(operationName, options, cb) {\n    const { updatedOptions, span } = createSpan(operationName, options);\n\n    try {\n      // NOTE: we really do need to await on this function here so we can handle any exceptions thrown and properly\n      // close the span.\n      const result = await cb(updatedOptions, span);\n\n      // otel 0.16+ needs this or else the code ends up being set as UNSET\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      return result;\n    } catch (err) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { parseKeyvaultIdentifier } from \"../../keyvault-common/src\";\n\n/**\n * Represents the segments that compose a Key Vault Key Id.\n */\nexport interface KeyVaultKeyIdentifier {\n  /**\n   * The complete representation of the Key Vault Key Id. For example:\n   *\n   *   https://<keyvault-name>.vault.azure.net/keys/<key-name>/<unique-version-id>\n   *\n   */\n  sourceId: string;\n\n  /**\n   * The URL of the Azure Key Vault instance to which the Key belongs.\n   */\n  vaultUrl: string;\n\n  /**\n   * The version of Key Vault Key. Might be undefined.\n   */\n  version?: string;\n\n  /**\n   * The name of the Key Vault Key.\n   */\n  name: string;\n}\n\n/**\n * Parses the given Key Vault Key Id. An example is:\n *\n *   https://<keyvault-name>.vault.azure.net/keys/<key-name>/<unique-version-id>\n *\n * On parsing the above Id, this function returns:\n *```ts\n *   {\n *      sourceId: \"https://<keyvault-name>.vault.azure.net/keys/<key-name>/<unique-version-id>\",\n *      vaultUrl: \"https://<keyvault-name>.vault.azure.net\",\n *      version: \"<unique-version-id>\",\n *      name: \"<key-name>\"\n *   }\n *```\n * @param id - The Id of the Key Vault Key.\n */\nexport function parseKeyVaultKeyIdentifier(id: string): KeyVaultKeyIdentifier {\n  const urlParts = id.split(\"/\");\n  const collection = urlParts[3];\n\n  return {\n    sourceId: id,\n    ...parseKeyvaultIdentifier(collection, id)\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  DeletedKeyBundle,\n  DeletedKeyItem,\n  KeyAttributes,\n  KeyBundle,\n  KeyItem\n} from \"./generated/models\";\nimport { parseKeyVaultKeyIdentifier } from \"./identifier\";\nimport { DeletedKey, KeyVaultKey, JsonWebKey, KeyOperation, KeyProperties } from \"./keysModels\";\n\n/**\n * @internal\n * Shapes the exposed {@link KeyVaultKey} based on either a received key bundle or deleted key bundle.\n */\nexport function getKeyFromKeyBundle(\n  bundle: KeyBundle | DeletedKeyBundle\n): KeyVaultKey | DeletedKey {\n  const keyBundle = bundle as KeyBundle;\n  const deletedKeyBundle = bundle as DeletedKeyBundle;\n\n  const parsedId = parseKeyVaultKeyIdentifier(keyBundle.key!.kid!);\n\n  const attributes: KeyAttributes = keyBundle.attributes || {};\n  delete keyBundle.attributes;\n\n  const resultObject: KeyVaultKey | DeletedKey = {\n    key: keyBundle.key as JsonWebKey,\n    id: keyBundle.key ? keyBundle.key.kid : undefined,\n    name: parsedId.name,\n    keyOperations: keyBundle.key ? (keyBundle.key.keyOps as KeyOperation[]) : undefined,\n    keyType: keyBundle.key ? keyBundle.key.kty : undefined,\n    properties: {\n      tags: keyBundle.tags,\n\n      enabled: attributes.enabled,\n      notBefore: attributes.notBefore,\n      expiresOn: attributes.expires,\n      createdOn: attributes.created,\n      updatedOn: attributes.updated,\n      recoverableDays: attributes.recoverableDays,\n      recoveryLevel: attributes.recoveryLevel,\n\n      vaultUrl: parsedId.vaultUrl,\n      version: parsedId.version,\n      name: parsedId.name,\n      managed: keyBundle.managed,\n\n      id: keyBundle.key ? keyBundle.key.kid : undefined\n    }\n  };\n\n  if (deletedKeyBundle.recoveryId) {\n    (resultObject as any).properties.recoveryId = deletedKeyBundle.recoveryId;\n    (resultObject as any).properties.scheduledPurgeDate = deletedKeyBundle.scheduledPurgeDate;\n    (resultObject as any).properties.deletedOn = deletedKeyBundle.deletedDate;\n  }\n\n  return resultObject;\n}\n\n/**\n * @internal\n * Shapes the exposed {@link DeletedKey} based on a received KeyItem.\n */\nexport function getDeletedKeyFromDeletedKeyItem(keyItem: DeletedKeyItem): DeletedKey {\n  const commonProperties = getKeyPropertiesFromKeyItem(keyItem);\n\n  return {\n    key: {\n      kid: keyItem.kid\n    },\n    id: keyItem.kid,\n    name: commonProperties.name,\n    properties: {\n      ...commonProperties,\n      recoveryId: keyItem.recoveryId,\n      scheduledPurgeDate: keyItem.scheduledPurgeDate,\n      deletedOn: keyItem.deletedDate\n    }\n  };\n}\n\n/**\n * @internal\n * Shapes the exposed {@link KeyProperties} based on a received KeyItem.\n */\nexport function getKeyPropertiesFromKeyItem(keyItem: KeyItem): KeyProperties {\n  const parsedId = parseKeyVaultKeyIdentifier(keyItem.kid!);\n  const attributes = keyItem.attributes || {};\n\n  const resultObject: KeyProperties = {\n    createdOn: attributes.created,\n    enabled: attributes?.enabled,\n    expiresOn: attributes?.expires,\n    id: keyItem.kid,\n    managed: keyItem.managed,\n    name: parsedId.name,\n    notBefore: attributes?.notBefore,\n    recoverableDays: attributes?.recoverableDays,\n    recoveryLevel: attributes?.recoveryLevel,\n    tags: keyItem.tags,\n    updatedOn: attributes.updated,\n    vaultUrl: parsedId.vaultUrl,\n    version: parsedId.version\n  };\n\n  return resultObject;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { delay, OperationOptions } from \"@azure/core-http\";\nimport { Poller, PollOperation, PollOperationState } from \"@azure/core-lro\";\nimport { KeyVaultClient } from \"../generated/keyVaultClient\";\n\n/**\n * Common parameters to a Key Vault Key Poller.\n */\nexport interface KeyVaultKeyPollerOptions {\n  vaultUrl: string;\n  client: KeyVaultClient;\n  name: string;\n  operationOptions?: OperationOptions;\n  intervalInMs?: number;\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the state of a Key Vault Key Poller's operation.\n */\nexport interface KeyVaultKeyPollOperationState<TResult> extends PollOperationState<TResult> {\n  /**\n   * The name of the key.\n   */\n  name: string;\n}\n\n/**\n * Common properties and methods of the Key Vault Key Pollers.\n */\nexport abstract class KeyVaultKeyPoller<\n  TState extends KeyVaultKeyPollOperationState<TResult>,\n  TResult\n> extends Poller<TState, TResult> {\n  /**\n   * Defines how much time the poller is going to wait before making a new request to the service.\n   */\n  public intervalInMs: number = 2000;\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   */\n  async delay(): Promise<void> {\n    return delay(this.intervalInMs);\n  }\n}\n\n/**\n * Optional parameters to the KeyVaultKeyPollOperation\n */\nexport interface KeyVaultKeyPollOperationOptions {\n  cancelMessage?: string;\n}\n\n/**\n * Common properties and methods of the Key Vault Key Poller operations.\n */\nexport class KeyVaultKeyPollOperation<TState, TResult> implements PollOperation<TState, TResult> {\n  private cancelMessage: string = \"\";\n\n  constructor(public state: TState, options: KeyVaultKeyPollOperationOptions = {}) {\n    if (options.cancelMessage) {\n      this.cancelMessage = options.cancelMessage;\n    }\n  }\n\n  /**\n   * Meant to reach to the service and update the Poller operation.\n   */\n  public async update(): Promise<PollOperation<TState, TResult>> {\n    throw new Error(\"Operation not supported.\");\n  }\n\n  /**\n   * Meant to reach to the service and cancel the Poller operation.\n   */\n  public async cancel(): Promise<PollOperation<TState, TResult>> {\n    throw new Error(this.cancelMessage);\n  }\n\n  /**\n   * Serializes the Poller operation.\n   */\n  public toString(): string {\n    return JSON.stringify({\n      state: this.state\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-http\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport { DeletedKey, DeleteKeyOptions, GetDeletedKeyOptions } from \"../../keysModels\";\nimport { getKeyFromKeyBundle } from \"../../transformations\";\nimport { KeyVaultKeyPollOperation, KeyVaultKeyPollOperationState } from \"../keyVaultKeyPoller\";\nimport { createTraceFunction } from \"../../../../keyvault-common/src\";\n\n/**\n * @internal\n */\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Keys.DeleteKeyPoller\");\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface DeleteKeyPollOperationState extends KeyVaultKeyPollOperationState<DeletedKey> {}\n\nexport class DeleteKeyPollOperation extends KeyVaultKeyPollOperation<\n  DeleteKeyPollOperationState,\n  DeletedKey\n> {\n  constructor(\n    public state: DeleteKeyPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {}\n  ) {\n    super(state, { cancelMessage: \"Canceling the deletion of a key is not supported.\" });\n  }\n\n  /**\n   * Sends a delete request for the given Key Vault Key's name to the Key Vault service.\n   * Since the Key Vault Key won't be immediately deleted, we have {@link beginDeleteKey}.\n   */\n  private deleteKey(name: string, options: DeleteKeyOptions = {}): Promise<DeletedKey> {\n    return withTrace(\"deleteKey\", options, async (updatedOptions) => {\n      const response = await this.client.deleteKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   */\n  private getDeletedKey(name: string, options: GetDeletedKeyOptions = {}): Promise<DeletedKey> {\n    return withTrace(\"getDeletedKey\", options, async (updatedOptions) => {\n      const response = await this.client.getDeletedKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * Reaches to the service and updates the delete key's poll operation.\n   */\n  public async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: DeleteKeyPollOperationState) => void;\n    } = {}\n  ): Promise<DeleteKeyPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    if (options.abortSignal) {\n      this.operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      const deletedKey = await this.deleteKey(name, this.operationOptions);\n      state.isStarted = true;\n      state.result = deletedKey;\n      if (!deletedKey.properties.recoveryId) {\n        state.isCompleted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getDeletedKey(name, this.operationOptions);\n        state.isCompleted = true;\n      } catch (error) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { DeleteKeyPollOperation, DeleteKeyPollOperationState } from \"./operation\";\nimport { DeletedKey } from \"../../keysModels\";\nimport { KeyVaultKeyPoller, KeyVaultKeyPollerOptions } from \"../keyVaultKeyPoller\";\n\n/**\n * Class that creates a poller that waits until a key finishes being deleted.\n */\nexport class DeleteKeyPoller extends KeyVaultKeyPoller<DeleteKeyPollOperationState, DeletedKey> {\n  constructor(options: KeyVaultKeyPollerOptions) {\n    const { vaultUrl, client, name, operationOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: DeleteKeyPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = new DeleteKeyPollOperation(\n      {\n        ...state,\n        name\n      },\n      vaultUrl,\n      client,\n      operationOptions\n    );\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { OperationOptions } from \"@azure/core-http\";\nimport { KeyVaultClient } from \"../../generated/keyVaultClient\";\nimport { KeyVaultKey, GetKeyOptions, RecoverDeletedKeyOptions } from \"../../keysModels\";\nimport { getKeyFromKeyBundle } from \"../../transformations\";\nimport { KeyVaultKeyPollOperation, KeyVaultKeyPollOperationState } from \"../keyVaultKeyPoller\";\n\nimport { createTraceFunction } from \"../../../../keyvault-common/src\";\n\n/**\n * @internal\n */\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Keys.RecoverDeletedKeyPoller\");\n\n/**\n * An interface representing the state of a delete key's poll operation\n */\nexport interface RecoverDeletedKeyPollOperationState\n  extends KeyVaultKeyPollOperationState<KeyVaultKey> {}\n\nexport class RecoverDeletedKeyPollOperation extends KeyVaultKeyPollOperation<\n  RecoverDeletedKeyPollOperationState,\n  KeyVaultKey\n> {\n  constructor(\n    public state: RecoverDeletedKeyPollOperationState,\n    private vaultUrl: string,\n    private client: KeyVaultClient,\n    private operationOptions: OperationOptions = {}\n  ) {\n    super(state, { cancelMessage: \"Canceling the recovery of a deleted key is not supported.\" });\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   */\n  private getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return withTrace(\"generatedClient.getKey\", options, async (updatedOptions) => {\n      const response = await this.client.getKey(\n        this.vaultUrl,\n        name,\n        updatedOptions?.version || \"\",\n        updatedOptions\n      );\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * Sends a request to recover a deleted Key Vault Key based on the given name.\n   * Since the Key Vault Key won't be immediately recover the deleted key, we have {@link beginRecoverDeletedKey}.\n   */\n  private async recoverDeletedKey(\n    name: string,\n    options: RecoverDeletedKeyOptions = {}\n  ): Promise<KeyVaultKey> {\n    return withTrace(\"generatedClient.recoverDeleteKey\", options, async (updatedOptions) => {\n      const response = await this.client.recoverDeletedKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * Reaches to the service and updates the delete key's poll operation.\n   */\n  public async update(\n    options: {\n      abortSignal?: AbortSignalLike;\n      fireProgress?: (state: RecoverDeletedKeyPollOperationState) => void;\n    } = {}\n  ): Promise<RecoverDeletedKeyPollOperation> {\n    const state = this.state;\n    const { name } = state;\n\n    const operationOptions = this.operationOptions;\n    if (options.abortSignal) {\n      operationOptions.abortSignal = options.abortSignal;\n    }\n\n    if (!state.isStarted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch {\n        // Nothing to do here.\n      }\n      if (!state.isCompleted) {\n        state.result = await this.recoverDeletedKey(name, operationOptions);\n        state.isStarted = true;\n      }\n    }\n\n    if (!state.isCompleted) {\n      try {\n        state.result = await this.getKey(name, operationOptions);\n        state.isCompleted = true;\n      } catch (error) {\n        if (error.statusCode === 403) {\n          // At this point, the resource exists but the user doesn't have access to it.\n          state.isCompleted = true;\n        } else if (error.statusCode !== 404) {\n          state.error = error;\n          state.isCompleted = true;\n          throw error;\n        }\n      }\n    }\n\n    return this;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RecoverDeletedKeyPollOperation, RecoverDeletedKeyPollOperationState } from \"./operation\";\nimport { KeyVaultKey } from \"../../keysModels\";\nimport { KeyVaultKeyPoller, KeyVaultKeyPollerOptions } from \"../keyVaultKeyPoller\";\n\n/**\n * Class that deletes a poller that waits until a key finishes being deleted\n */\nexport class RecoverDeletedKeyPoller extends KeyVaultKeyPoller<\n  RecoverDeletedKeyPollOperationState,\n  KeyVaultKey\n> {\n  constructor(options: KeyVaultKeyPollerOptions) {\n    const { vaultUrl, client, name, operationOptions, intervalInMs = 2000, resumeFrom } = options;\n\n    let state: RecoverDeletedKeyPollOperationState | undefined;\n\n    if (resumeFrom) {\n      state = JSON.parse(resumeFrom).state;\n    }\n\n    const operation = new RecoverDeletedKeyPollOperation(\n      {\n        ...state,\n        name\n      },\n      vaultUrl,\n      client,\n      operationOptions\n    );\n\n    super(operation);\n\n    this.intervalInMs = intervalInMs;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport * as coreHttp from \"@azure/core-http\";\nimport {\n  DeletionRecoveryLevel,\n  JsonWebKeyType as KeyType,\n  KnownJsonWebKeyType as KnownKeyTypes,\n  JsonWebKeyOperation as KeyOperation,\n  KnownJsonWebKeyOperation as KnownKeyOperations\n} from \"./generated/models\";\nimport { KeyCurveName } from \"./cryptographyClientModels\";\n\nexport { KeyType, KnownKeyTypes, KeyOperation, KnownKeyOperations };\n\n/**\n * The latest supported Key Vault service API version\n */\nexport const LATEST_API_VERSION = \"7.2\";\n\n/**\n * The optional parameters accepted by the KeyVault's KeyClient\n */\nexport interface KeyClientOptions extends coreHttp.PipelineOptions {\n  /**\n   * The version of the KeyVault's service API to make calls against.\n   */\n  serviceVersion?: string;\n}\n\n/**\n * The optional parameters accepted by the KeyVault's CryptographyClient\n */\nexport interface CryptographyClientOptions extends KeyClientOptions {}\n\n/**\n * As of http://tools.ietf.org/html/draft-ietf-jose-json-web-key-18\n */\nexport interface JsonWebKey {\n  /**\n   * Key identifier.\n   */\n  kid?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct', \"oct-HSM\"\n   */\n  kty?: KeyType;\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * RSA modulus.\n   */\n  n?: Uint8Array;\n  /**\n   * RSA public exponent.\n   */\n  e?: Uint8Array;\n  /**\n   * RSA private exponent, or the D component of an EC private key.\n   */\n  d?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  dp?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  dq?: Uint8Array;\n  /**\n   * RSA private key parameter.\n   */\n  qi?: Uint8Array;\n  /**\n   * RSA secret prime.\n   */\n  p?: Uint8Array;\n  /**\n   * RSA secret prime, with `p < q`.\n   */\n  q?: Uint8Array;\n  /**\n   * Symmetric key.\n   */\n  k?: Uint8Array;\n  /**\n   * HSM Token, used with 'Bring Your Own Key'.\n   */\n  t?: Uint8Array;\n  /**\n   * Elliptic curve name. For valid values, see KeyCurveName. Possible values include:\n   * 'P-256', 'P-384', 'P-521', 'P-256K'\n   */\n  crv?: KeyCurveName;\n  /**\n   * X component of an EC public key.\n   */\n  x?: Uint8Array;\n  /**\n   * Y component of an EC public key.\n   */\n  y?: Uint8Array;\n}\n\n/**\n * An interface representing a Key Vault Key, with its name, value and {@link KeyProperties}.\n */\nexport interface KeyVaultKey {\n  /**\n   * The key value.\n   */\n  key?: JsonWebKey;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct', \"oct-HSM\"\n   */\n  keyType?: KeyType;\n  /**\n   * Operations allowed on this key\n   */\n  keyOperations?: KeyOperation[];\n  /**\n   * The properties of the key.\n   */\n  properties: KeyProperties;\n}\n\n/**\n * An interface representing the Properties of {@link KeyVaultKey}\n */\nexport interface KeyProperties {\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * The vault URI.\n   */\n  vaultUrl: string;\n  /**\n   * The version of the key. May be undefined.\n   */\n  version?: string;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Creation time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly createdOn?: Date;\n  /**\n   * Last updated time in UTC.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly updatedOn?: Date;\n  /**\n   * Reflects the deletion recovery level currently in effect for keys in the current vault.\n   * If it contains 'Purgeable' the key can be permanently deleted by a privileged\n   * user; otherwise, only the system can purge the key, at the end of the\n   * retention interval. Possible values include: 'Purgeable',\n   * 'Recoverable+Purgeable', 'Recoverable',\n   * 'Recoverable+ProtectedSubscription'\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly recoveryLevel?: DeletionRecoveryLevel;\n  /**\n   * The retention dates of the softDelete data.\n   * The value should be `>=7` and `<=90` when softDelete enabled.\n   * **NOTE: This property will not be serialized. It can only be populated by the server.**\n   */\n  recoverableDays?: number;\n\n  /**\n   * True if the secret's lifetime is managed by\n   * key vault. If this is a secret backing a certificate, then managed will be\n   * true.\n   * **NOTE: This property will not be serialized. It can only be populated by\n   * the server.**\n   */\n  readonly managed?: boolean;\n}\n\n/**\n * An interface representing a deleted Key Vault Key.\n */\nexport interface DeletedKey {\n  /**\n   * The key value.\n   */\n  key?: JsonWebKey;\n  /**\n   * The name of the key.\n   */\n  name: string;\n  /**\n   * Key identifier.\n   */\n  id?: string;\n  /**\n   * JsonWebKey Key Type (kty), as defined in\n   * https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40. Possible values include:\n   * 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct', \"oct-HSM\"\n   */\n  keyType?: KeyType;\n  /**\n   * Operations allowed on this key\n   */\n  keyOperations?: KeyOperation[];\n  /**\n   * The properties of the key.\n   */\n  properties: KeyProperties & {\n    /**\n     * The url of the recovery object, used to\n     * identify and recover the deleted key.\n     */\n    readonly recoveryId?: string;\n    /**\n     * The time when the key is scheduled to be purged, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    readonly scheduledPurgeDate?: Date;\n    /**\n     * The time when the key was deleted, in UTC\n     * **NOTE: This property will not be serialized. It can only be populated by\n     * the server.**\n     */\n    deletedOn?: Date;\n  };\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createKey}\n */\nexport interface CreateKeyOptions extends coreHttp.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  readonly expiresOn?: Date;\n  /**\n   * The key size in bits. For example: 2048, 3072, or 4096 for RSA.\n   */\n  keySize?: number;\n  /**\n   * Elliptic curve name. For valid values, see KeyCurveName.\n   * Possible values include: 'P-256', 'P-384', 'P-521', 'P-256K'\n   */\n  curve?: KeyCurveName;\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hsm?: boolean;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteKey} and {@link beginRecoverDeletedKey}\n */\nexport interface KeyPollerOptions extends coreHttp.OperationOptions {\n  /**\n   * Time between each polling\n   */\n  intervalInMs?: number;\n  /**\n   * A serialized poller, used to resume an existing operation\n   */\n  resumeFrom?: string;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginDeleteKey}\n */\nexport interface BeginDeleteKeyOptions extends KeyPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link beginRecoverDeletedKey}\n */\nexport interface BeginRecoverDeletedKeyOptions extends KeyPollerOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createEcKey}\n */\nexport interface CreateEcKeyOptions extends CreateKeyOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createRsaKey}\n */\nexport interface CreateRsaKeyOptions extends CreateKeyOptions {\n  /** The public exponent for a RSA key. */\n  publicExponent?: number;\n}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link createOctKey}\n */\nexport interface CreateOctKeyOptions extends CreateKeyOptions {}\n\n/**\n * An interface representing the optional parameters that can be\n * passed to {@link importKey}\n */\nexport interface ImportKeyOptions extends coreHttp.OperationOptions {\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n  /**\n   * Whether to import as a hardware key (HSM) or software key.\n   */\n  hardwareProtected?: boolean;\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n}\n\n/**\n * Options for {@link updateKeyProperties}.\n */\nexport interface UpdateKeyPropertiesOptions extends coreHttp.OperationOptions {\n  /**\n   * Json web key operations. For more\n   * information on possible key operations, see KeyOperation.\n   */\n  keyOps?: KeyOperation[];\n  /**\n   * Determines whether the object is enabled.\n   */\n  enabled?: boolean;\n  /**\n   * Not before date in UTC.\n   */\n  notBefore?: Date;\n  /**\n   * Expiry date in UTC.\n   */\n  expiresOn?: Date;\n  /**\n   * Application specific metadata in the form of key-value pairs.\n   */\n  tags?: { [propertyName: string]: string };\n}\n\n/**\n * Options for {@link getKey}.\n */\nexport interface GetKeyOptions extends coreHttp.OperationOptions {\n  /**\n   * The version of the secret to retrieve. If not\n   * specified the latest version of the secret will be retrieved.\n   */\n  version?: string;\n}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listKeys}.\n */\nexport interface ListKeysOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeys}.\n */\nexport interface ListPropertiesOfKeysOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listPropertiesOfKeyVersions}.\n */\nexport interface ListPropertiesOfKeyVersionsOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing optional parameters for KeyClient paged operations passed to {@link listDeletedKeys}.\n */\nexport interface ListDeletedKeysOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link getDeletedKey}.\n */\nexport interface GetDeletedKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link purgeDeletedKey}.\n */\nexport interface PurgeDeletedKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * Options for {@link recoverDeletedKey}.\n */\nexport interface RecoverDeletedKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * @internal\n * Options for {@link deleteKey}.\n */\nexport interface DeleteKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link backupKey}.\n */\nexport interface BackupKeyOptions extends coreHttp.OperationOptions {}\n\n/**\n * Options for {@link restoreKeyBackup}.\n */\nexport interface RestoreKeyBackupOptions extends coreHttp.OperationOptions {}\n\n/**\n * An interface representing the options of the cryptography API methods, go to the {@link CryptographyClient} for more information.\n */\nexport interface CryptographyOptions extends coreHttp.OperationOptions {}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createHash as cryptoCreateHash,\n  createVerify as cryptoCreateVerify,\n  Verify,\n  randomBytes as cryptoRandomBytes\n} from \"crypto\";\n\n/**\n * @internal\n * Mapping between signature algorithms and their corresponding hash algorithms. Externally used for testing.\n **/\nconst algorithmToHashAlgorithm: { [s: string]: string } = {\n  ES256: \"SHA256\",\n  ES256K: \"SHA256\",\n  PS256: \"SHA256\",\n  RS256: \"SHA256\",\n  ES384: \"SHA384\",\n  PS384: \"SHA384\",\n  RS384: \"SHA384\",\n  ES512: \"SHA512\",\n  PS512: \"SHA512\",\n  RS512: \"SHA512\"\n};\n\n/**\n * @internal\n * Use the platform-local hashing functionality\n */\nexport async function createHash(algorithm: string, data: Uint8Array): Promise<Buffer> {\n  const hashAlgorithm = algorithmToHashAlgorithm[algorithm];\n  if (!hashAlgorithm) {\n    throw new Error(\n      `Invalid algorithm ${algorithm} passed to createHash. Supported algorithms: ${Object.keys(\n        algorithmToHashAlgorithm\n      ).join(\", \")}`\n    );\n  }\n  const hash = cryptoCreateHash(hashAlgorithm);\n  hash.update(Buffer.from(data));\n  const digest = hash.digest();\n  return digest;\n}\n\n/**\n * @internal\n * Use the platform-local verify functionality\n */\nexport function createVerify(algorithm: string, data: Uint8Array): Verify {\n  const verifyAlgorithm = algorithmToHashAlgorithm[algorithm];\n  if (!verifyAlgorithm) {\n    throw new Error(\n      `Invalid algorithm ${algorithm} passed to createHash. Supported algorithms: ${Object.keys(\n        algorithmToHashAlgorithm\n      ).join(\", \")}`\n    );\n  }\n  const verifier = cryptoCreateVerify(verifyAlgorithm);\n  verifier.update(Buffer.from(data));\n  verifier.end();\n  return verifier;\n}\n\n/**\n * @internal\n * Use the platform-local randomBytes functionality\n */\nexport function randomBytes(length: number): Uint8Array {\n  return cryptoRandomBytes(length);\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createPipelineFromOptions,\n  isTokenCredential,\n  TokenCredential,\n  signingPolicy\n} from \"@azure/core-http\";\nimport {\n  EncryptParameters,\n  EncryptOptions,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  WrapKeyOptions,\n  WrapResult,\n  VerifyOptions,\n  VerifyResult,\n  DecryptParameters,\n  DecryptOptions,\n  DecryptResult,\n  UnwrapKeyOptions,\n  SignOptions,\n  SignResult\n} from \"../cryptographyClientModels\";\nimport { SDK_VERSION } from \"../constants\";\nimport { UnwrapResult } from \"../cryptographyClientModels\";\nimport { KeyVaultClient } from \"../generated\";\nimport { parseKeyVaultKeyIdentifier } from \"../identifier\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyVaultKey,\n  LATEST_API_VERSION\n} from \"../keysModels\";\nimport { getKeyFromKeyBundle } from \"../transformations\";\nimport { createHash } from \"./crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./models\";\nimport { logger } from \"../log\";\nimport {\n  createTraceFunction,\n  TracedFunction,\n  challengeBasedAuthenticationPolicy\n} from \"../../../keyvault-common/src\";\n\nconst withTrace: TracedFunction = createTraceFunction(\n  \"Azure.KeyVault.Keys.RemoteCryptographyProvider\"\n);\n\n/**\n * The remote cryptography provider is used to run crypto operations against KeyVault.\n * @internal\n */\nexport class RemoteCryptographyProvider implements CryptographyProvider {\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\n          \"x-ms-keyvault-region\",\n          \"x-ms-keyvault-network-info\",\n          \"x-ms-keyvault-service-version\"\n        ]\n      }\n    };\n\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      createPipelineFromOptions(internalPipelineOptions, authPolicy)\n    );\n\n    this.key = key;\n\n    let keyId: string;\n    if (typeof key === \"string\") {\n      keyId = key;\n    } else {\n      keyId = key.id!;\n    }\n\n    try {\n      const parsed = parseKeyVaultKeyIdentifier(keyId);\n      if (parsed.name === \"\") {\n        throw new Error(\"Could not find 'name' of key in key URL\");\n      }\n\n      if (!parsed.version || parsed.version === \"\") {\n        throw new Error(\"Could not find 'version' of key in key URL\");\n      }\n\n      if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n        throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n      }\n\n      this.vaultUrl = parsed.vaultUrl;\n      this.name = parsed.name;\n      this.version = parsed.version;\n    } catch (err) {\n      logger.error(err);\n\n      throw new Error(`${keyId} is not a valid Key Vault key ID`);\n    }\n  }\n\n  // The remote client supports all algorithms and all operations.\n  isSupported(_algorithm: string, _operation: CryptographyProviderOperation): boolean {\n    return true;\n  }\n\n  encrypt(\n    encryptParameters: EncryptParameters,\n    options: EncryptOptions = {}\n  ): Promise<EncryptResult> {\n    const { algorithm, plaintext, ...params } = encryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return withTrace(\"encrypt\", requestOptions, async (updatedOptions) => {\n      const result = await this.client.encrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        plaintext,\n        updatedOptions\n      );\n\n      return {\n        algorithm: encryptParameters.algorithm,\n        result: result.result!,\n        keyID: this.getKeyID(),\n        additionalAuthenticatedData: result.additionalAuthenticatedData,\n        authenticationTag: result.authenticationTag,\n        iv: result.iv\n      };\n    });\n  }\n\n  decrypt(\n    decryptParameters: DecryptParameters,\n    options: DecryptOptions = {}\n  ): Promise<DecryptResult> {\n    const { algorithm, ciphertext, ...params } = decryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return withTrace(\"decrypt\", requestOptions, async (updatedOptions) => {\n      const result = await this.client.decrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        ciphertext,\n        updatedOptions\n      );\n      return {\n        result: result.result!,\n        keyID: this.getKeyID(),\n        algorithm\n      };\n    });\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    return withTrace(\"wrapKey\", options, async (updatedOptions) => {\n      const result = await this.client.wrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        keyToWrap,\n        updatedOptions\n      );\n\n      return {\n        result: result.result!,\n        algorithm,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    return withTrace(\"unwrapKey\", options, async (updatedOptions) => {\n      const result = await this.client.unwrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        encryptedKey,\n        updatedOptions\n      );\n\n      return {\n        result: result.result!,\n        algorithm,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n\n  sign(algorithm: string, digest: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return withTrace(\"sign\", options, async (updatedOptions) => {\n      const result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        updatedOptions\n      );\n\n      return { result: result.result!, algorithm, keyID: this.getKeyID() };\n    });\n  }\n\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verifyData\", options, async (updatedOptions) => {\n      const hash = await createHash(algorithm, data);\n      return this.verify(algorithm, hash, signature, updatedOptions);\n    });\n  }\n\n  verify(\n    algorithm: string,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verify\", options, async (updatedOptions) => {\n      const response = await this.client.verify(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        signature,\n        updatedOptions\n      );\n      return {\n        result: response.value ? response.value : false,\n        keyID: this.getKeyID()\n      };\n    });\n  }\n\n  signData(algorithm: string, data: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return withTrace(\"signData\", options, async (updatedOptions) => {\n      const digest = await createHash(algorithm, data);\n      const result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        updatedOptions\n      );\n      return { result: result.result!, algorithm, keyID: this.getKeyID() };\n    });\n  }\n\n  /**\n   * The base URL to the vault.\n   */\n  readonly vaultUrl: string;\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyId(): string | undefined {\n    return this.getKeyID();\n  }\n\n  /**\n   * Gets the {@link KeyVaultKey} used for cryptography operations, fetching it\n   * from KeyVault if necessary.\n   * @param options - Additional options.\n   */\n  getKey(options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return withTrace(\"getKey\", options, async (updatedOptions) => {\n      if (typeof this.key === \"string\") {\n        if (!this.name || this.name === \"\") {\n          throw new Error(\"getKey requires a key with a name\");\n        }\n        const response = await this.client.getKey(\n          this.vaultUrl,\n          this.name,\n          options && options.version ? options.version : this.version ? this.version : \"\",\n          updatedOptions\n        );\n        this.key = getKeyFromKeyBundle(response);\n      }\n      return this.key;\n    });\n  }\n\n  /**\n   * @internal\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor,\n   * it can be either a string with the URL of a Key Vault Key, or an already parsed {@link KeyVaultKey}.\n   * @internal\n   */\n  private key: string | KeyVaultKey;\n\n  /**\n   * Name of the key the client represents\n   * @internal\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   * @internal\n   */\n  private version: string;\n\n  /**\n   * Attempts to retrieve the ID of the key.\n   * @internal\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.id;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JsonWebKey } from \"../keysModels\";\n\n/**\n * @internal\n * Encodes a length of a packet in DER format\n */\nfunction encodeLength(length: number): Uint8Array {\n  if (length <= 127) {\n    return Uint8Array.of(length);\n  } else if (length < 256) {\n    return Uint8Array.of(0x81, length);\n  } else if (length < 65536) {\n    return Uint8Array.of(0x82, length >> 8, length & 0xff);\n  } else {\n    throw new Error(\"Unsupported length to encode\");\n  }\n}\n\n/**\n * @internal\n * Encodes a buffer for DER, as sets the id to the given id\n */\nfunction encodeBuffer(buffer: Uint8Array, bufferId: number): Uint8Array {\n  if (buffer.length === 0) {\n    return buffer;\n  }\n\n  let result = new Uint8Array(buffer);\n\n  // If the high bit is set, prepend a 0\n  if (result[0] & 0x80) {\n    const array = new Uint8Array(result.length + 1);\n    array[0] = 0;\n    array.set(result, 1);\n    result = array;\n  }\n\n  // Prepend the DER header for this buffer\n  const encodedLength = encodeLength(result.length);\n  const totalLength = 1 + encodedLength.length + result.length;\n\n  const outputBuffer = new Uint8Array(totalLength);\n  outputBuffer[0] = bufferId;\n  outputBuffer.set(encodedLength, 1);\n  outputBuffer.set(result, 1 + encodedLength.length);\n\n  return outputBuffer;\n}\n\nfunction makeSequence(encodedParts: Uint8Array[]): string {\n  const totalLength = encodedParts.reduce((sum, part) => sum + part.length, 0);\n  const sequence = new Uint8Array(totalLength);\n\n  for (let i = 0; i < encodedParts.length; i++) {\n    const previousLength = i > 0 ? encodedParts[i - 1].length : 0;\n    sequence.set(encodedParts[i], previousLength);\n  }\n\n  const full_encoded = encodeBuffer(sequence, 0x30); // SEQUENCE\n  return Buffer.from(full_encoded).toString(\"base64\");\n}\n\n/**\n * Fill in the PEM with 64 character lines as per RFC:\n *\n * \"To represent the encapsulated text of a PEM message, the encoding\n * function's output is delimited into text lines (using local\n * conventions), with each line except the last containing exactly 64\n * printable characters and the final line containing 64 or fewer\n * printable characters.\"\n */\nfunction formatBase64Sequence(base64Sequence: string): string {\n  const lines = base64Sequence.match(/.{1,64}/g);\n  let result = \"\";\n  if (lines) {\n    for (const line of lines) {\n      result += line;\n      result += \"\\n\";\n    }\n  } else {\n    throw new Error(\"Could not create correct PEM\");\n  }\n  return result;\n}\n\n/**\n * @internal\n * Encode a JWK to PEM format. To do so, it internally repackages the JWK as a DER\n * that is then encoded as a PEM.\n */\nexport function convertJWKtoPEM(key: JsonWebKey): string {\n  let result = \"\";\n\n  if (key.n && key.e) {\n    const parts = [key.n, key.e];\n    const encodedParts = parts.map((part) => encodeBuffer(part, 0x2)); // INTEGER\n    const base64Sequence = makeSequence(encodedParts);\n    result += \"-----BEGIN RSA PUBLIC KEY-----\\n\";\n    result += formatBase64Sequence(base64Sequence);\n    result += \"-----END RSA PUBLIC KEY-----\\n\";\n  }\n\n  if (!result.length) {\n    throw new Error(\"Unsupported key format for local operations\");\n  }\n\n  return result.slice(0, -1); // Removing the last new line\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-http\";\nimport {\n  DecryptOptions,\n  DecryptParameters,\n  DecryptResult,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  SignatureAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult\n} from \"..\";\n\nexport class LocalCryptographyUnsupportedError extends Error {}\n\n/**\n * The set of operations a {@link CryptographyProvider} supports.\n *\n * This corresponds to every single method on the interface so that providers\n * can declare whether they support this method or not.\n *\n * Purposely more granular than {@link KnownKeyOperations} because some providers\n * support verifyData but not verify.\n * @internal\n */\nexport type CryptographyProviderOperation =\n  | \"encrypt\"\n  | \"decrypt\"\n  | \"wrapKey\"\n  | \"unwrapKey\"\n  | \"sign\"\n  | \"signData\"\n  | \"verify\"\n  | \"verifyData\";\n\n/**\n *\n * Represents an object that can perform cryptography operations.\n * @internal\n */\nexport interface CryptographyProvider {\n  /**\n   * Encrypts the given plaintext with the specified encryption parameters.\n   * @internal\n   *\n   * @param encryptParameters - The encryption parameters, keyed on the encryption algorithm chosen.\n   * @param options - Additional options.\n   */\n  encrypt(encryptParameters: EncryptParameters, options?: EncryptOptions): Promise<EncryptResult>;\n\n  /**\n   * Decrypts the given ciphertext with the specified decryption parameters.\n   * @internal\n   *\n   * @param decryptParameters - The decryption parameters.\n   * @param options - Additional options.\n   */\n  decrypt(decryptParameters: DecryptParameters, options?: DecryptOptions): Promise<DecryptResult>;\n\n  /**\n   *\n   * @param algorithm - The algorithm to check support for.\n   * @param operation - The {@link CryptographyProviderOperation} to check support for.\n   */\n  isSupported(algorithm: string, operation: CryptographyProviderOperation): boolean;\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   * @internal\n   *\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param keyToWrap - The key to wrap.\n   * @param options - Additional options.\n   */\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options?: WrapKeyOptions\n  ): Promise<WrapResult>;\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   * @internal\n   *\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options?: UnwrapKeyOptions\n  ): Promise<UnwrapResult>;\n\n  /**\n   * Cryptographically sign the digest of a message\n   * @internal\n   *\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options?: SignOptions\n  ): Promise<SignResult>;\n\n  /**\n   * Cryptographically sign a block of data\n   * @internal\n   *\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options?: SignOptions\n  ): Promise<SignResult>;\n\n  /**\n   * Verify the signed message digest\n   * @internal\n   *\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options?: VerifyOptions\n  ): Promise<VerifyResult>;\n\n  /**\n   * Verify the signed block of data\n   * @internal\n   *\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param updatedOptions - Additional options.\n   */\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    updatedOptions: OperationOptions\n  ): Promise<VerifyResult>;\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { RSA_PKCS1_OAEP_PADDING, RSA_PKCS1_PADDING } from \"constants\";\nimport { publicEncrypt } from \"crypto\";\nimport { createVerify } from \"./crypto\";\nimport {\n  JsonWebKey,\n  DecryptOptions,\n  EncryptOptions,\n  EncryptParameters,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  UnwrapKeyOptions,\n  VerifyOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  DecryptParameters,\n  DecryptResult,\n  SignatureAlgorithm,\n  SignOptions,\n  SignResult,\n  UnwrapResult,\n  WrapResult\n} from \"..\";\nimport { convertJWKtoPEM } from \"./conversions\";\nimport {\n  CryptographyProvider,\n  CryptographyProviderOperation,\n  LocalCryptographyUnsupportedError\n} from \"./models\";\n\n/**\n * An RSA cryptography provider supporting RSA algorithms.\n */\nexport class RsaCryptographyProvider implements CryptographyProvider {\n  constructor(key: JsonWebKey) {\n    this.key = key;\n  }\n\n  isSupported(algorithm: string, operation: CryptographyProviderOperation): boolean {\n    return (\n      this.applicableAlgorithms.includes(algorithm) && this.applicableOperations.includes(operation)\n    );\n  }\n\n  encrypt(encryptParameters: EncryptParameters, _options?: EncryptOptions): Promise<EncryptResult> {\n    this.ensureValid();\n    const keyPEM = convertJWKtoPEM(this.key);\n\n    const padding =\n      encryptParameters.algorithm === \"RSA1_5\" ? RSA_PKCS1_PADDING : RSA_PKCS1_OAEP_PADDING;\n\n    return Promise.resolve({\n      algorithm: encryptParameters.algorithm,\n      keyID: this.key.kid,\n      result: publicEncrypt(\n        { key: keyPEM, padding: padding },\n        Buffer.from(encryptParameters.plaintext)\n      )\n    });\n  }\n\n  decrypt(\n    _decryptParameters: DecryptParameters,\n    _options?: DecryptOptions\n  ): Promise<DecryptResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Decrypting using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    _options?: WrapKeyOptions\n  ): Promise<WrapResult> {\n    this.ensureValid();\n    const keyPEM = convertJWKtoPEM(this.key);\n\n    const padding = algorithm === \"RSA1_5\" ? RSA_PKCS1_PADDING : RSA_PKCS1_OAEP_PADDING;\n\n    return Promise.resolve({\n      algorithm: algorithm as KeyWrapAlgorithm,\n      result: publicEncrypt({ key: keyPEM, padding }, Buffer.from(keyToWrap)),\n      keyID: this.key.kid\n    });\n  }\n\n  unwrapKey(\n    _algorithm: KeyWrapAlgorithm,\n    _encryptedKey: Uint8Array,\n    _options?: UnwrapKeyOptions\n  ): Promise<UnwrapResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Unwrapping a key using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  sign(\n    _algorithm: SignatureAlgorithm,\n    _digest: Uint8Array,\n    _options?: SignOptions\n  ): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing a digest using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  signData(\n    _algorithm: SignatureAlgorithm,\n    _data: Uint8Array,\n    _options?: SignOptions\n  ): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing a block of data using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  async verify(\n    _algorithm: SignatureAlgorithm,\n    _digest: Uint8Array,\n    _signature: Uint8Array,\n    _options?: VerifyOptions\n  ): Promise<VerifyResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Verifying a digest using a local JsonWebKey is not supported.\"\n    );\n  }\n\n  verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    _options?: VerifyOptions\n  ): Promise<VerifyResult> {\n    this.ensureValid();\n    const keyPEM = convertJWKtoPEM(this.key);\n\n    const verifier = createVerify(algorithm, data);\n    return Promise.resolve({\n      result: verifier.verify(keyPEM, Buffer.from(signature)),\n      keyID: this.key.kid\n    });\n  }\n\n  /**\n   * The {@link JsonWebKey} used to perform crypto operations.\n   * @internal\n   */\n  private key: JsonWebKey;\n\n  /**\n   * The set of algorithms this provider supports\n   * @internal\n   */\n  private applicableAlgorithms: string[] = [\n    \"RSA1_5\",\n    \"RSA-OAEP\",\n    \"PS256\",\n    \"RS256\",\n    \"PS384\",\n    \"RS384\",\n    \"PS512\",\n    \"RS512\"\n  ];\n\n  /**\n   * The set of operations this provider supports\n   * @internal\n   */\n  private applicableOperations: CryptographyProviderOperation[] = [\n    \"encrypt\",\n    \"wrapKey\",\n    \"verifyData\"\n  ];\n\n  /**\n   * Mapping between signature algorithms and their corresponding hash algorithms. Externally used for testing.\n   * @internal\n   */\n  signatureAlgorithmToHashAlgorithm: { [s: string]: string } = {\n    PS256: \"SHA256\",\n    RS256: \"SHA256\",\n    PS384: \"SHA384\",\n    RS384: \"SHA384\",\n    PS512: \"SHA512\",\n    RS512: \"SHA512\"\n  };\n\n  private ensureValid(): void {\n    if (\n      this.key &&\n      this.key.kty?.toUpperCase() !== \"RSA\" &&\n      this.key.kty?.toUpperCase() !== \"RSA-HSM\"\n    ) {\n      throw new Error(\"Key type does not match the algorithm RSA\");\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions } from \"@azure/core-http\";\nimport * as crypto from \"crypto\";\nimport {\n  EncryptOptions,\n  EncryptResult,\n  DecryptOptions,\n  DecryptResult,\n  KeyWrapAlgorithm,\n  WrapKeyOptions,\n  WrapResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  SignOptions,\n  SignResult,\n  VerifyOptions,\n  VerifyResult,\n  AesCbcEncryptParameters,\n  JsonWebKey\n} from \"..\";\nimport { AesCbcDecryptParameters } from \"../cryptographyClientModels\";\nimport {\n  CryptographyProvider,\n  CryptographyProviderOperation,\n  LocalCryptographyUnsupportedError\n} from \"./models\";\n\n/**\n * An AES cryptography provider supporting AES algorithms.\n * @internal\n */\nexport class AesCryptographyProvider implements CryptographyProvider {\n  private key: JsonWebKey;\n  constructor(key: JsonWebKey) {\n    this.key = key;\n  }\n  encrypt(\n    encryptParameters: AesCbcEncryptParameters,\n    _options?: EncryptOptions\n  ): Promise<EncryptResult> {\n    const { algorithm, keySizeInBytes } = this.supportedAlgorithms[encryptParameters.algorithm];\n    const iv = encryptParameters.iv || crypto.randomBytes(16);\n\n    this.ensureValid(keySizeInBytes);\n\n    const cipher = crypto.createCipheriv(algorithm, this.key.k!.subarray(0, keySizeInBytes), iv);\n    let encrypted = cipher.update(Buffer.from(encryptParameters.plaintext));\n    encrypted = Buffer.concat([encrypted, cipher.final()]);\n\n    return Promise.resolve({\n      algorithm: encryptParameters.algorithm,\n      result: encrypted,\n      iv: iv\n    });\n  }\n\n  decrypt(\n    decryptParameters: AesCbcDecryptParameters,\n    _options?: DecryptOptions\n  ): Promise<DecryptResult> {\n    const { algorithm, keySizeInBytes } = this.supportedAlgorithms[decryptParameters.algorithm];\n\n    this.ensureValid(keySizeInBytes);\n\n    const decipher = crypto.createDecipheriv(\n      algorithm,\n      this.key.k!.subarray(0, keySizeInBytes),\n      decryptParameters.iv\n    );\n    let dec = decipher.update(Buffer.from(decryptParameters.ciphertext));\n    dec = Buffer.concat([dec, decipher.final()]);\n\n    return Promise.resolve({\n      algorithm: decryptParameters.algorithm,\n      result: dec\n    });\n  }\n\n  isSupported(algorithm: string, operation: CryptographyProviderOperation): boolean {\n    if (!this.key.k) {\n      return false;\n    }\n\n    if (!Object.keys(this.supportedAlgorithms).includes(algorithm)) {\n      return false;\n    }\n\n    if (!this.supportedOperations.includes(operation)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * The set of algorithms this provider supports.\n   * For AES encryption, the values include the underlying algorithm used in crypto\n   * as well as the key size in bytes.\n   *\n   * We start with support for A[SIZE]CBCPAD which uses the PKCS padding (the default padding scheme in node crypto)\n   */\n  private supportedAlgorithms: { [s: string]: { algorithm: string; keySizeInBytes: number } } = {\n    A128CBCPAD: {\n      algorithm: \"aes-128-cbc\",\n      keySizeInBytes: 128 >> 3\n    },\n    A192CBCPAD: {\n      algorithm: \"aes-192-cbc\",\n      keySizeInBytes: 192 >> 3\n    },\n    A256CBCPAD: {\n      algorithm: \"aes-256-cbc\",\n      keySizeInBytes: 256 >> 3\n    }\n  };\n\n  private supportedOperations: CryptographyProviderOperation[] = [\"encrypt\", \"decrypt\"];\n\n  wrapKey(\n    _algorithm: KeyWrapAlgorithm,\n    _keyToWrap: Uint8Array,\n    _options?: WrapKeyOptions\n  ): Promise<WrapResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Wrapping a key using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  unwrapKey(\n    _algorithm: KeyWrapAlgorithm,\n    _encryptedKey: Uint8Array,\n    _options?: UnwrapKeyOptions\n  ): Promise<UnwrapResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Unwrapping a key using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  sign(_algorithm: string, _digest: Uint8Array, _options?: SignOptions): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  signData(_algorithm: string, _data: Uint8Array, _options?: SignOptions): Promise<SignResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Signing using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  verify(\n    _algorithm: string,\n    _digest: Uint8Array,\n    _signature: Uint8Array,\n    _options?: VerifyOptions\n  ): Promise<VerifyResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Verifying using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n  verifyData(\n    _algorithm: string,\n    _data: Uint8Array,\n    _signature: Uint8Array,\n    _updatedOptions: OperationOptions\n  ): Promise<VerifyResult> {\n    throw new LocalCryptographyUnsupportedError(\n      \"Verifying using a local JsonWebKey is not supported for AES.\"\n    );\n  }\n\n  private ensureValid(keySizeInBytes: number): void {\n    if (\n      this.key &&\n      this.key.kty?.toUpperCase() !== \"OCT\" &&\n      this.key.kty?.toUpperCase() !== \"OCT-HSM\"\n    ) {\n      throw new Error(\"Key type does not match the key type oct or oct-hsm\");\n    }\n\n    if (!this.key.k) {\n      throw new Error(\"Symmetric key is required\");\n    }\n\n    if (this.key.k.length < keySizeInBytes) {\n      throw new Error(`Key must be at least ${keySizeInBytes << 3} bits`);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions, TokenCredential } from \"@azure/core-http\";\nimport {\n  JsonWebKey,\n  KeyVaultKey,\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyOperation,\n  KnownKeyOperations\n} from \"./keysModels\";\nimport {\n  EncryptionAlgorithm,\n  KeyWrapAlgorithm,\n  WrapResult,\n  UnwrapResult,\n  DecryptResult,\n  SignatureAlgorithm,\n  SignResult,\n  VerifyResult,\n  EncryptResult,\n  EncryptOptions,\n  DecryptOptions,\n  WrapKeyOptions,\n  UnwrapKeyOptions,\n  EncryptParameters,\n  SignOptions,\n  VerifyOptions,\n  DecryptParameters,\n  CryptographyClientKey,\n  AesCbcEncryptParameters,\n  AesCbcEncryptionAlgorithm\n} from \"./cryptographyClientModels\";\nimport { RemoteCryptographyProvider } from \"./cryptography/remoteCryptographyProvider\";\nimport { randomBytes } from \"./cryptography/crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./cryptography/models\";\nimport { RsaCryptographyProvider } from \"./cryptography/rsaCryptographyProvider\";\nimport { AesCryptographyProvider } from \"./cryptography/aesCryptographyProvider\";\nimport { createTraceFunction } from \"../../keyvault-common/src\";\n\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Keys.CryptographyClient\");\n\n/**\n * A client used to perform cryptographic operations on an Azure Key vault key\n * or a local {@link JsonWebKey}.\n */\nexport class CryptographyClient {\n  /**\n   * The key the CryptographyClient currently holds.\n   */\n  private key: CryptographyClientKey;\n\n  /**\n   * The remote provider, which would be undefined if used in local mode.\n   */\n  private remoteProvider?: RemoteCryptographyProvider;\n\n  /**\n   * Constructs a new instance of the Cryptography client for the given key\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient, CryptographyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let keyClient = new KeyClient(vaultUrl, credentials);\n   * let keyVaultKey = await keyClient.getKey(\"MyKey\");\n   *\n   * let client = new CryptographyClient(keyVaultKey.id, credentials);\n   * // or\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * ```\n   * @param key - The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions?: CryptographyClientOptions\n  );\n  /**\n   * Constructs a new instance of the Cryptography client for the given key in local mode.\n   *\n   * Example usage:\n   * ```ts\n   * import { CryptographyClient } from \"@azure/keyvault-keys\";\n   *\n   * const jsonWebKey: JsonWebKey = {\n   *   // ...\n   * };\n   * const client = new CryptographyClient(jsonWebKey);\n   * ```\n   * @param key - The JsonWebKey to use during cryptography operations.\n   */\n  constructor(key: JsonWebKey);\n  /**\n   * Internal constructor implementation for either local or Key Vault backed keys.\n   * @param key - The key to use during cryptography tasks.\n   * @param credential - Teh credential to use when constructing a Key Vault Cryptography client.\n   */\n  constructor(\n    key: string | KeyVaultKey | JsonWebKey,\n    credential?: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    if (typeof key === \"string\") {\n      // Key URL for remote-local operations.\n      this.key = {\n        kind: \"identifier\",\n        value: key\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else if (\"name\" in key) {\n      // KeyVault key for remote-local operations.\n      this.key = {\n        kind: \"KeyVaultKey\",\n        value: key\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else {\n      // JsonWebKey for local-only operations.\n      this.key = {\n        kind: \"JsonWebKey\",\n        value: key\n      };\n    }\n  }\n\n  /**\n   * The base URL to the vault. If a local {@link JsonWebKey} is used vaultUrl will be empty.\n   */\n  get vaultUrl(): string {\n    return this.remoteProvider?.vaultUrl || \"\";\n  }\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyID(): string | undefined {\n    if (this.key.kind === \"identifier\") {\n      return this.key.value;\n    } else if (this.key.kind === \"KeyVaultKey\") {\n      return this.key.value.id;\n    } else {\n      return this.key.value.kid;\n    }\n  }\n\n  /**\n   * Encrypts the given plaintext with the specified encryption parameters.\n   * Depending on the algorithm set in the encryption parameters, the set of possible encryption parameters will change.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt({ algorithm: \"RSA1_5\", plaintext: Buffer.from(\"My Message\")});\n   * let result = await client.encrypt({ algorithm: \"A256GCM\", plaintext: Buffer.from(\"My Message\"), additionalAuthenticatedData: Buffer.from(\"My authenticated data\")});\n   * ```\n   * @param encryptParameters - The encryption parameters, keyed on the encryption algorithm chosen.\n   * @param options - Additional options.\n   */\n  public encrypt(\n    encryptParameters: EncryptParameters,\n    options?: EncryptOptions\n  ): Promise<EncryptResult>;\n  /**\n   * Encrypts the given plaintext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt(\"RSA1_5\", Buffer.from(\"My Message\"));\n   * ```\n   * @param algorithm - The algorithm to use.\n   * @param plaintext - The text to encrypt.\n   * @param options - Additional options.\n   * @deprecated Use `encrypt({ algorithm, plaintext }, options)` instead.\n   */\n  public encrypt(\n    algorithm: EncryptionAlgorithm,\n    plaintext: Uint8Array,\n    options?: EncryptOptions\n  ): Promise<EncryptResult>;\n  public encrypt(\n    ...args:\n      | [EncryptParameters, EncryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, EncryptOptions?]\n  ): Promise<EncryptResult> {\n    const [parameters, options] = this.disambiguateEncryptArguments(args);\n    return withTrace(\"encrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Encrypt);\n      this.initializeIV(parameters);\n      const provider = await this.getProvider(\"encrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.encrypt(parameters, updatedOptions);\n      } catch (error) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.encrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  private initializeIV(parameters: EncryptParameters): void {\n    // For AES-GCM the service **must** generate the IV, so we only populate it for AES-CBC\n    const algorithmsRequiringIV: AesCbcEncryptionAlgorithm[] = [\n      \"A128CBC\",\n      \"A128CBCPAD\",\n      \"A192CBC\",\n      \"A192CBCPAD\",\n      \"A256CBC\",\n      \"A256CBCPAD\"\n    ];\n\n    if (parameters.algorithm in algorithmsRequiringIV) {\n      try {\n        const cbcParams = parameters as AesCbcEncryptParameters;\n        if (!cbcParams.iv) {\n          cbcParams.iv = randomBytes(16);\n        }\n      } catch (e) {\n        throw new Error(\n          `Unable to initialize IV for algorithm ${parameters.algorithm}. You may pass a valid IV to avoid this error. Error: ${e.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The encrypt arguments\n   */\n  private disambiguateEncryptArguments(\n    args: [EncryptParameters, EncryptOptions?] | [string, Uint8Array, EncryptOptions?]\n  ): [EncryptParameters, EncryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", buffer, options]\n      return [\n        {\n          algorithm: args[0],\n          plaintext: args[1]\n        } as EncryptParameters,\n        args[2] || {}\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", plaintext: buffer }, options]\n      return [args[0], (args[1] || {}) as EncryptOptions];\n    }\n  }\n\n  /**\n   * Decrypts the given ciphertext with the specified decryption parameters.\n   * Depending on the algorithm used in the decryption parameters, the set of possible decryption parameters will change.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt({ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer });\n   * let result = await client.decrypt({ algorithm: \"A256GCM\", iv: ivFromEncryptResult, authenticationTag: tagFromEncryptResult });\n   * ```\n   * @param decryptParameters - The decryption parameters.\n   * @param options - Additional options.\n   */\n  public async decrypt(\n    decryptParameters: DecryptParameters,\n    options?: DecryptOptions\n  ): Promise<DecryptResult>;\n  /**\n   * Decrypts the given ciphertext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt(\"RSA1_5\", encryptedBuffer);\n   * ```\n   * @param algorithm - The algorithm to use.\n   * @param ciphertext - The text to decrypt.\n   * @param options - Additional options.\n   * @deprecated Use `decrypt({ algorithm, ciphertext }, options)` instead.\n   */\n  public decrypt(\n    algorithm: EncryptionAlgorithm,\n    ciphertext: Uint8Array,\n    options?: DecryptOptions\n  ): Promise<DecryptResult>;\n  public decrypt(\n    ...args:\n      | [DecryptParameters, DecryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, DecryptOptions?]\n  ): Promise<DecryptResult> {\n    const [parameters, options] = this.disambiguateDecryptArguments(args);\n\n    return withTrace(\"decrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Decrypt);\n      const provider = await this.getProvider(\"decrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.decrypt(parameters, updatedOptions);\n      } catch (error) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.decrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The decrypt arguments\n   */\n  private disambiguateDecryptArguments(\n    args: [DecryptParameters, DecryptOptions?] | [string, Uint8Array, DecryptOptions?]\n  ): [DecryptParameters, DecryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", encryptedBuffer, options]\n      return [\n        {\n          algorithm: args[0],\n          ciphertext: args[1]\n        } as DecryptParameters,\n        args[2] || {}\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer }, options]\n      return [args[0], (args[1] || {}) as DecryptOptions];\n    }\n  }\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param key - The key to wrap.\n   * @param options - Additional options.\n   */\n  public wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    key: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    return withTrace(\"wrapKey\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.WrapKey);\n      const provider = await this.getProvider(\"wrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.wrapKey(algorithm, key, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.wrapKey(algorithm, key, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  public unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    return withTrace(\"unwrapKey\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.UnwrapKey);\n      const provider = await this.getProvider(\"unwrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.unwrapKey(algorithm, encryptedKey, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.unwrapKey(algorithm, encryptedKey, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  public sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    return withTrace(\"sign\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"sign\", algorithm, updatedOptions);\n      try {\n        return provider.sign(algorithm, digest, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.sign(algorithm, digest, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  public verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verify\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verify\", algorithm, updatedOptions);\n      try {\n        return provider.verify(algorithm, digest, signature, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verify(algorithm, digest, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  public signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    return withTrace(\"signData\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"signData\", algorithm, updatedOptions);\n      try {\n        return provider.signData(algorithm, data, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.signData(algorithm, data, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param options - Additional options.\n   */\n  public verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verifyData\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verifyData\", algorithm, updatedOptions);\n      try {\n        return provider.verifyData(algorithm, data, signature, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verifyData(algorithm, data, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * @internal\n   * Retrieves the {@link JsonWebKey} from the Key Vault.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKeyMaterial();\n   * ```\n   */\n  private async getKeyMaterial(options: GetKeyOptions): Promise<JsonWebKey> {\n    const key = await this.fetchKey(options);\n\n    switch (key.kind) {\n      case \"JsonWebKey\":\n        return key.value;\n      case \"KeyVaultKey\":\n        return key.value.key!;\n      default:\n        throw new Error(\"Failed to exchange Key ID for an actual KeyVault Key.\");\n    }\n  }\n\n  /**\n   * Returns the underlying key used for cryptographic operations.\n   * If needed, fetches the key from KeyVault and exchanges the ID for the actual key.\n   * @param options - The additional options.\n   */\n  private async fetchKey<T extends OperationOptions>(options: T): Promise<CryptographyClientKey> {\n    if (this.key.kind === \"identifier\") {\n      // Exchange the identifier with the actual key when needed\n      const key = await this.remoteProvider!.getKey(options);\n      this.key = { kind: \"KeyVaultKey\", value: key };\n    }\n    return this.key;\n  }\n\n  private providers?: CryptographyProvider[];\n  /**\n   * Gets the provider that support this algorithm and operation.\n   * The available providers are ordered by priority such that the first provider that supports this\n   * operation is the one we should use.\n   * @param operation - The {@link KeyOperation}.\n   * @param algorithm - The algorithm to use.\n   */\n  private async getProvider<T extends OperationOptions>(\n    operation: CryptographyProviderOperation,\n    algorithm: string,\n    options: T\n  ): Promise<CryptographyProvider> {\n    if (!this.providers) {\n      const keyMaterial = await this.getKeyMaterial(options);\n      // Add local crypto providers as needed\n      this.providers = [\n        new RsaCryptographyProvider(keyMaterial),\n        new AesCryptographyProvider(keyMaterial)\n      ];\n\n      // If the remote provider exists, we're in hybrid-mode. Otherwise we're in local-only mode.\n      // If we're in hybrid mode the remote provider is used as a catch-all and should be last in the list.\n      if (this.remoteProvider) {\n        this.providers.push(this.remoteProvider);\n      }\n    }\n\n    const providers = this.providers.filter((p) => p.isSupported(algorithm, operation));\n\n    if (providers.length === 0) {\n      throw new Error(\n        `Unable to support operation: \"${operation}\" with algorithm: \"${algorithm}\" ${\n          this.key.kind === \"JsonWebKey\" ? \"using a local JsonWebKey\" : \"\"\n        }`\n      );\n    }\n\n    // Return the first provider that supports this request\n    return providers[0];\n  }\n\n  private ensureValid(key: CryptographyClientKey, operation?: KeyOperation): void {\n    if (key.kind === \"KeyVaultKey\") {\n      const keyOps = key.value.keyOperations;\n      const { notBefore, expiresOn } = key.value.properties;\n      const now = new Date();\n\n      // Check KeyVault Key Expiration\n      if (notBefore && now < notBefore) {\n        throw new Error(`Key ${key.value.id} can't be used before ${notBefore.toISOString()}`);\n      }\n\n      if (expiresOn && now > expiresOn) {\n        throw new Error(`Key ${key.value.id} expired at ${expiresOn.toISOString()}`);\n      }\n\n      // Check Key operations\n      if (operation && keyOps && !keyOps?.includes(operation)) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.id}`);\n      }\n    } else if (key.kind === \"JsonWebKey\") {\n      // Check JsonWebKey Key operations\n      if (operation && key.value.keyOps && !key.value.keyOps?.includes(operation)) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.kid}`);\n      }\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint @typescript-eslint/member-ordering: 0 */\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport {\n  PipelineOptions,\n  TokenCredential,\n  createPipelineFromOptions,\n  isTokenCredential,\n  signingPolicy\n} from \"@azure/core-http\";\n\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollerLike, PollOperationState } from \"@azure/core-lro\";\n\nimport {\n  DeletionRecoveryLevel,\n  KnownDeletionRecoveryLevel,\n  KeyVaultClientGetKeysOptionalParams,\n  KnownJsonWebKeyType\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { SDK_VERSION } from \"./constants\";\nimport { challengeBasedAuthenticationPolicy } from \"../../keyvault-common/src\";\n\nimport { DeleteKeyPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedKeyPoller } from \"./lro/recover/poller\";\n\nimport {\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CryptographyOptions,\n  DeletedKey,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyOperation,\n  KnownKeyOperations,\n  KeyPollerOptions,\n  KeyType,\n  KnownKeyTypes,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  KeyVaultKey,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PurgeDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  UpdateKeyPropertiesOptions,\n  KeyClientOptions,\n  CryptographyClientOptions,\n  LATEST_API_VERSION,\n  CreateOctKeyOptions\n} from \"./keysModels\";\n\nimport { CryptographyClient } from \"./cryptographyClient\";\n\nimport {\n  DecryptResult,\n  KeyCurveName,\n  KnownKeyCurveNames,\n  EncryptionAlgorithm,\n  KnownEncryptionAlgorithms,\n  SignatureAlgorithm,\n  KnownSignatureAlgorithms,\n  KeyWrapAlgorithm,\n  SignResult,\n  UnwrapResult,\n  VerifyResult,\n  WrapResult,\n  EncryptResult,\n  DecryptOptions,\n  EncryptOptions,\n  SignOptions,\n  UnwrapKeyOptions,\n  VerifyOptions,\n  WrapKeyOptions,\n  EncryptParameters,\n  DecryptParameters,\n  RsaEncryptionAlgorithm,\n  RsaEncryptParameters,\n  AesGcmEncryptionAlgorithm,\n  AesCbcEncryptionAlgorithm,\n  AesCbcEncryptParameters,\n  AesGcmEncryptParameters,\n  AesCbcDecryptParameters,\n  AesGcmDecryptParameters,\n  RsaDecryptParameters,\n  VerifyDataOptions\n} from \"./cryptographyClientModels\";\n\nimport { KeyVaultKeyIdentifier, parseKeyVaultKeyIdentifier } from \"./identifier\";\nimport {\n  getDeletedKeyFromDeletedKeyItem,\n  getKeyFromKeyBundle,\n  getKeyPropertiesFromKeyItem\n} from \"./transformations\";\nimport { createTraceFunction } from \"../../keyvault-common/src\";\n\nexport {\n  CryptographyClientOptions,\n  KeyClientOptions,\n  BackupKeyOptions,\n  CreateEcKeyOptions,\n  CreateKeyOptions,\n  CreateRsaKeyOptions,\n  CreateOctKeyOptions,\n  CryptographyClient,\n  CryptographyOptions,\n  RsaEncryptionAlgorithm,\n  RsaDecryptParameters,\n  AesGcmEncryptionAlgorithm,\n  AesGcmDecryptParameters,\n  AesCbcEncryptionAlgorithm,\n  AesCbcDecryptParameters,\n  DecryptParameters,\n  DecryptOptions,\n  DecryptResult,\n  DeletedKey,\n  DeletionRecoveryLevel,\n  KnownDeletionRecoveryLevel,\n  RsaEncryptParameters,\n  AesGcmEncryptParameters,\n  AesCbcEncryptParameters,\n  EncryptParameters,\n  EncryptOptions,\n  EncryptResult,\n  GetDeletedKeyOptions,\n  GetKeyOptions,\n  ImportKeyOptions,\n  JsonWebKey,\n  KeyCurveName,\n  KnownKeyCurveNames,\n  EncryptionAlgorithm,\n  KnownEncryptionAlgorithms,\n  KeyOperation,\n  KnownKeyOperations,\n  KeyType,\n  KnownKeyTypes,\n  KeyPollerOptions,\n  BeginDeleteKeyOptions,\n  BeginRecoverDeletedKeyOptions,\n  KeyProperties,\n  SignatureAlgorithm,\n  KnownSignatureAlgorithms,\n  KeyVaultKey,\n  KeyWrapAlgorithm,\n  ListPropertiesOfKeysOptions,\n  ListPropertiesOfKeyVersionsOptions,\n  ListDeletedKeysOptions,\n  PageSettings,\n  PagedAsyncIterableIterator,\n  KeyVaultKeyIdentifier,\n  parseKeyVaultKeyIdentifier,\n  PipelineOptions,\n  PollOperationState,\n  PollerLike,\n  PurgeDeletedKeyOptions,\n  RestoreKeyBackupOptions,\n  SignOptions,\n  SignResult,\n  UnwrapKeyOptions,\n  UnwrapResult,\n  UpdateKeyPropertiesOptions,\n  VerifyOptions,\n  VerifyDataOptions,\n  VerifyResult,\n  WrapKeyOptions,\n  WrapResult,\n  logger\n};\n\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Keys.KeyClient\");\n\n/**\n * The KeyClient provides methods to manage {@link KeyVaultKey} in the\n * Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultKeys. The\n * client also supports listing {@link DeletedKey} for a soft-delete enabled Azure Key\n * Vault.\n */\nexport class KeyClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * @internal\n   * @hidden\n   * A reference to the auto-generated Key Vault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * Creates an instance of KeyClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new KeyClient(vaultUrl, credentials);\n   * ```\n   * @param vaultUrl - the URL of the Key Vault. It should have this shape: `https://${your-key-vault-name}.vault.azure.net`\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests. Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: KeyClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n    const userAgentOptions = pipelineOptions.userAgentOptions;\n\n    pipelineOptions.userAgentOptions = {\n      userAgentPrefix:\n        userAgentOptions && userAgentOptions.userAgentPrefix\n          ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n          : libInfo\n    };\n\n    const authPolicy = isTokenCredential(credential)\n      ? challengeBasedAuthenticationPolicy(credential)\n      : signingPolicy(credential);\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\n          \"x-ms-keyvault-region\",\n          \"x-ms-keyvault-network-info\",\n          \"x-ms-keyvault-service-version\"\n        ]\n      }\n    };\n\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      createPipelineFromOptions(internalPipelineOptions, authPolicy)\n    );\n  }\n\n  /**\n   * The create key operation can be used to create any key type in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Create an elliptic-curve key:\n   * let result = await client.createKey(\"MyKey\", \"EC\");\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param keyType - The type of the key. One of the following: 'EC', 'EC-HSM', 'RSA', 'RSA-HSM', 'oct'.\n   * @param options - The optional parameters.\n   */\n  public createKey(\n    name: string,\n    keyType: KeyType,\n    options?: CreateKeyOptions\n  ): Promise<KeyVaultKey> {\n    let unflattenedOptions = {};\n\n    if (options) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n    }\n    return withTrace(\"createKey\", unflattenedOptions, async (updatedOptions) => {\n      const response = await this.client.createKey(this.vaultUrl, name, keyType, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The createEcKey method creates a new elliptic curve key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createEcKey(\"MyKey\", { curve: \"P-256\" });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async createEcKey(name: string, options?: CreateEcKeyOptions): Promise<KeyVaultKey> {\n    const keyType = options?.hsm ? KnownJsonWebKeyType.ECHSM : KnownJsonWebKeyType.EC;\n    return this.createKey(name, keyType, options);\n  }\n\n  /**\n   * The createRSAKey method creates a new RSA key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createRsaKey(\"MyKey\", { keySize: 2048 });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async createRsaKey(name: string, options?: CreateRsaKeyOptions): Promise<KeyVaultKey> {\n    const keyType = options?.hsm ? KnownJsonWebKeyType.RSAHSM : KnownJsonWebKeyType.RSA;\n    return this.createKey(name, keyType, options);\n  }\n\n  /**\n   * The createOctKey method creates a new OCT key in Azure Key Vault. If the named key\n   * already exists, Azure Key Vault creates a new version of the key. It requires the keys/create\n   * permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let result = await client.createOctKey(\"MyKey\", { hsm: true });\n   * ```\n   * Creates a new key, stores it, then returns key parameters and properties to the client.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async createOctKey(name: string, options?: CreateOctKeyOptions): Promise<KeyVaultKey> {\n    const keyType = options?.hsm ? KnownJsonWebKeyType.OctHSM : KnownJsonWebKeyType.Oct;\n    return this.createKey(name, keyType, options);\n  }\n\n  /**\n   * The import key operation may be used to import any key type into an Azure Key Vault. If the\n   * named key already exists, Azure Key Vault creates a new version of the key. This operation\n   * requires the keys/import permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * // Key contents in myKeyContents\n   * let result = await client.importKey(\"MyKey\", myKeyContents);\n   * ```\n   * Imports an externally created key, stores it, and returns key parameters and properties\n   * to the client.\n   * @param name - Name for the imported key.\n   * @param key - The JSON web key.\n   * @param options - The optional parameters.\n   */\n  public importKey(\n    name: string,\n    key: JsonWebKey,\n    options?: ImportKeyOptions\n  ): Promise<KeyVaultKey> {\n    let unflattenedOptions = {};\n\n    if (options) {\n      const {\n        enabled,\n        notBefore,\n        expiresOn: expires,\n        hardwareProtected: hsm,\n        ...remainingOptions\n      } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires,\n          hsm\n        }\n      };\n    }\n\n    return withTrace(`importKey`, unflattenedOptions, async (updatedOptions) => {\n      const response = await this.client.importKey(this.vaultUrl, name, key, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The delete operation applies to any key stored in Azure Key Vault. Individual versions\n   * of a key can not be deleted, only all versions of a given key at once.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the key is deleted.\n   *\n   * This operation requires the keys/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const poller = await client.beginDeleteKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginDeleteKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedKey = await poller.pollUntilDone();\n   * console.log(deletedKey);\n   * ```\n   * Deletes a key from a specified key vault.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public async beginDeleteKey(\n    name: string,\n    options: BeginDeleteKeyOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const poller = new DeleteKeyPoller({\n      name,\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options\n    });\n\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n\n    return poller;\n  }\n\n  /**\n   * The updateKeyProperties method changes specified properties of an existing stored key. Properties that\n   * are not specified in the request are left unchanged. The value of a key itself cannot be\n   * changed. This operation requires the keys/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let keyName = \"MyKey\";\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(keyName);\n   * let result = await client.updateKeyProperties(keyName, key.properties.version, { enabled: false });\n   * ```\n   * Updates the properties associated with a specified key in a given key vault.\n   * @param name - The name of the key.\n   * @param keyVersion - The version of the key.\n   * @param options - The optional parameters.\n   */\n  public updateKeyProperties(\n    name: string,\n    keyVersion: string,\n    options: UpdateKeyPropertiesOptions = {}\n  ): Promise<KeyVaultKey> {\n    return withTrace(`updateKeyProperties`, options, async (updatedOptions) => {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = updatedOptions;\n      const unflattenedOptions = {\n        ...remainingOptions,\n        keyAttributes: {\n          enabled,\n          notBefore,\n          expires\n        }\n      };\n      const response = await this.client.updateKey(\n        this.vaultUrl,\n        name,\n        keyVersion,\n        unflattenedOptions\n      );\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The getKey method gets a specified key and is applicable to any key stored in Azure Key Vault.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getKey(\"MyKey\");\n   * ```\n   * Get a specified key from a given key vault.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public getKey(name: string, options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return withTrace(`getKey`, options, async (updatedOptions) => {\n      const response = await this.client.getKey(\n        this.vaultUrl,\n        name,\n        options && options.version ? options.version : \"\",\n        updatedOptions\n      );\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedKey method returns the specified deleted key along with its properties.\n   * This operation requires the keys/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let key = await client.getDeletedKey(\"MyDeletedKey\");\n   * ```\n   * Gets the specified deleted key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public getDeletedKey(name: string, options: GetDeletedKeyOptions = {}): Promise<DeletedKey> {\n    return withTrace(`getDeletedKey`, options, async (updatedOptions) => {\n      const response = await this.client.getDeletedKey(this.vaultUrl, name, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * The purge deleted key operation removes the key permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the keys/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\")\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedKey(\"MyKey\");\n   * ```\n   * Permanently deletes the specified key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public purgeDeletedKey(name: string, options: PurgeDeletedKeyOptions = {}): Promise<void> {\n    return withTrace(`purgeDeletedKey`, options, async (updatedOptions) => {\n      await this.client.purgeDeletedKey(this.vaultUrl, name, updatedOptions);\n    });\n  }\n\n  /**\n   * Recovers the deleted key in the specified vault. This operation can only be performed on a\n   * soft-delete enabled vault.\n   *\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the deleted key is recovered.\n   *\n   * This operation requires the keys/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new KeyClient(url, credentials);\n   * await client.createKey(\"MyKey\", \"EC\");\n   * const deletePoller = await client.beginDeleteKey(\"MyKey\");\n   * await deletePoller.pollUntilDone();\n   * const poller = await client.beginRecoverDeletedKey(\"MyKey\");\n   *\n   * // Serializing the poller\n   * const serialized = poller.toString();\n   * // A new poller can be created with:\n   * // await client.beginRecoverDeletedKey(\"MyKey\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const key = await poller.pollUntilDone();\n   * console.log(key);\n   * ```\n   * Recovers the deleted key to the latest version.\n   * @param name - The name of the deleted key.\n   * @param options - The optional parameters.\n   */\n  public async beginRecoverDeletedKey(\n    name: string,\n    options: BeginRecoverDeletedKeyOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedKey>, DeletedKey>> {\n    const poller = new RecoverDeletedKeyPoller({\n      name,\n      vaultUrl: this.vaultUrl,\n      client: this.client,\n      intervalInMs: options.intervalInMs,\n      resumeFrom: options.resumeFrom,\n      operationOptions: options\n    });\n    // This will initialize the poller's operation (the deletion of the key).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified key be downloaded to the client. All versions of the\n   * key will be downloaded. This operation requires the keys/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * ```\n   * Backs up the specified key.\n   * @param name - The name of the key.\n   * @param options - The optional parameters.\n   */\n  public backupKey(name: string, options: BackupKeyOptions = {}): Promise<Uint8Array | undefined> {\n    return withTrace(`backupKey`, options, async (updatedOptions) => {\n      const response = await this.client.backupKey(this.vaultUrl, name, updatedOptions);\n      return response.value;\n    });\n  }\n\n  /**\n   * Restores a backed up key, and all its versions, to a vault. This operation requires the\n   * keys/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * let backupContents = await client.backupKey(\"MyKey\");\n   * // ...\n   * let key = await client.restoreKeyBackup(backupContents);\n   * ```\n   * Restores a backed up key to a vault.\n   * @param backup - The backup blob associated with a key bundle.\n   * @param options - The optional parameters.\n   */\n  public async restoreKeyBackup(\n    backup: Uint8Array,\n    options: RestoreKeyBackupOptions = {}\n  ): Promise<KeyVaultKey> {\n    return withTrace(`restoreKeyBackup`, options, async (updatedOptions) => {\n      const response = await this.client.restoreKey(this.vaultUrl, backup, updatedOptions);\n      return getKeyFromKeyBundle(response);\n    });\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the pagination of {@link listPropertiesOfKeyVersions}.\n   * @param name - The name of the Key Vault Key.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsPage(\n    name: string,\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeyVersionsOptions\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfKeyVersionsPage\",\n        optionsComplete,\n        async (updatedOptions) => this.client.getKeyVersions(this.vaultUrl, name, updatedOptions)\n      );\n\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfKeyVersionsPage\",\n        options || {},\n        async (updatedOptions) =>\n          this.client.getKeyVersions(continuationState.continuationToken!, name, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeyVersions}.\n   * @param name - The name of the Key Vault Key.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeyVersionsAll(\n    name: string,\n    options?: ListPropertiesOfKeyVersionsOptions\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeyVersionsPage(name, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given key in the vault. The full key identifier, properties, and tags are provided\n   * in the response. This operation requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeyVersions(\"MyKey\")) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key version: \", key);\n   * }\n   * ```\n   * @param name - Name of the key to fetch versions for\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfKeyVersions(\n    name: string,\n    options: ListPropertiesOfKeyVersionsOptions = {}\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const iter = this.listPropertiesOfKeyVersionsAll(name, options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfKeyVersionsPage(name, settings, options)\n    };\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the pagination of {@link listPropertiesOfKeys}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysPage(\n    continuationState: PageSettings,\n    options?: ListPropertiesOfKeysOptions\n  ): AsyncIterableIterator<KeyProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await withTrace(\n        \"listPropertiesOfKeysPage\",\n        optionsComplete,\n        async (updatedOptions) => this.client.getKeys(this.vaultUrl, updatedOptions)\n      );\n\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"KeysClient.listPropertiesOfKeysPage\",\n        options || {},\n        async (updatedOptions) =>\n          this.client.getKeys(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getKeyPropertiesFromKeyItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the iteration of all the available results of {@link listPropertiesOfKeys}.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listPropertiesOfKeysAll(\n    options?: ListPropertiesOfKeysOptions\n  ): AsyncIterableIterator<KeyProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const keyProperties of client.listPropertiesOfKeys()) {\n   *   const key = await client.getKey(keyProperties.name);\n   *   console.log(\"key: \", key);\n   * }\n   * ```\n   * List all keys in the vault\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfKeys(\n    options: ListPropertiesOfKeysOptions = {}\n  ): PagedAsyncIterableIterator<KeyProperties> {\n    const iter = this.listPropertiesOfKeysAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listPropertiesOfKeysPage(settings, options)\n    };\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the pagination of {@link listDeletedKeys}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysPage(\n    continuationState: PageSettings,\n    options?: ListDeletedKeysOptions\n  ): AsyncIterableIterator<DeletedKey[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: KeyVaultClientGetKeysOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options\n      };\n      const currentSetResponse = await withTrace(\n        \"listDeletedKeysPage\",\n        optionsComplete,\n        async (updatedOptions) => this.client.getDeletedKeys(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getDeletedKeyFromDeletedKeyItem, this);\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await withTrace(\n        \"listDeletedKeysPage\",\n        options || {},\n        async (updatedOptions) =>\n          this.client.getDeletedKeys(continuationState.continuationToken!, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(getDeletedKeyFromDeletedKeyItem, this);\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * @internal\n   * @hidden\n   * Deals with the iteration of all the available results of {@link listDeletedKeys}.\n   * @param options - Common options for the iterative endpoints.\n   */\n  private async *listDeletedKeysAll(\n    options?: ListDeletedKeysOptions\n  ): AsyncIterableIterator<DeletedKey> {\n    const f = {};\n\n    for await (const page of this.listDeletedKeysPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted keys in the vault.  The full key identifier and properties are provided\n   * in the response. No values are returned for the keys. This operations requires the keys/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new KeyClient(url, credentials);\n   * for await (const deletedKey of client.listDeletedKeys()) {\n   *   console.log(\"deleted key: \", deletedKey);\n   * }\n   * ```\n   * List all keys in the vault\n   * @param options - The optional parameters.\n   */\n  public listDeletedKeys(\n    options: ListDeletedKeysOptions = {}\n  ): PagedAsyncIterableIterator<DeletedKey> {\n    const iter = this.listDeletedKeysAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedKeysPage(settings, options)\n    };\n  }\n}\n"],"names":["createClientLogger","coreHttp.ServiceClient","coreHttp.getDefaultUserAgentValue","coreHttp.operationOptionsToRequestOptionsBase","coreHttp.Serializer","Mappers.KeyBundle","Mappers.KeyVaultError","Mappers.KeyCreateParameters","Parameters.apiVersion","Parameters.vaultBaseUrl","Parameters.keyName","Parameters.contentType","Parameters.accept","Mappers.KeyImportParameters","Mappers.DeletedKeyBundle","Parameters.keyName1","Mappers.KeyUpdateParameters","Parameters.keyVersion","Mappers.KeyListResult","Parameters.maxresults","Mappers.BackupKeyResult","Mappers.KeyRestoreParameters","Mappers.KeyOperationResult","Mappers.KeyOperationsParameters","Mappers.KeySignParameters","Mappers.KeyVerifyResult","Mappers.KeyVerifyParameters","Mappers.DeletedKeyListResult","Parameters.nextLink","ExpiringAccessTokenCache","BaseRequestPolicy","Constants","url.parse","createSpanFunction","SpanStatusCode","Poller","delay","withTrace","cryptoCreateHash","cryptoCreateVerify","cryptoRandomBytes","isTokenCredential","signingPolicy","createPipelineFromOptions","RSA_PKCS1_PADDING","RSA_PKCS1_OAEP_PADDING","publicEncrypt","crypto.randomBytes","crypto.createCipheriv","crypto.createDecipheriv","__asyncValues"],"mappings":"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"}